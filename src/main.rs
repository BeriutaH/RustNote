// use mysql::*;
// use mysql::prelude::*;
// use serde::Deserialize;
// use std::fs;


// #[derive(Debug, Deserialize)]
// struct DatabaseConfig {
//     host: String,
//     port: u16,
//     user: String,
//     password: String,
//     name: String,
//     pool_size: Option<u32>,
// }

// #[derive(Debug, Deserialize)]
// struct Config {
//     database: DatabaseConfig,
// }

// fn load_config() -> Config {
//     let config_content = fs::read_to_string("config.yml").expect("é…ç½®æ–‡ä»¶è¯»å–å¤±è´¥");
//     serde_yaml::from_str(&config_content).expect("é…ç½®è§£æå¤±è´¥")
// }
// use core::num;
// use std::io;  // è·å–ç”¨æˆ·è¾“å…¥çš„åº“ std è¡¨ç¤ºæ ‡å‡†åº“
// use std::cmp::Ordering;  // æšä¸¾ç±»å‹ï¼Œå†…å«ä¸‰ä¸ªç±»å‹
// use rand::Rng;  // å¼•å…¥ç¬¬ä¸‰æ–¹åŒ…

// use std::{error::Error, f32::consts::E, fs::File, io::{self, Read}};

// use std::fmt::Display;


// use core::{hash, num};
// use std::{cell::RefCell, os::unix::thread, rc::{Rc, Weak}};
// use std::{thread, time::Duration, vec};

// use std::env::consts;


// use rut::Post;
// #[tokio::main]
// async fn main() {
mod ticket;

fn main() {
    // let secret_num = rand::thread_rng().gen_range(1, 101);
    // println!("çŒœæ•°!è¯·è¾“å…¥æ‚¨æ‰€çŒœæµ‹çš„æ•°å­—");
    // println!("éšæœºæ•°å€¼æ˜¯: {}", secret_num);

    // loop {
    //     let mut guess = String::new();  // mut è¡¨ç¤ºæ˜¯å¯å˜çš„å˜é‡ï¼Œå¦‚æœæ²¡æœ‰å£°æ˜å°±æ˜¯ä¸å¯å˜  :: è¡¨ç¤ºé‡Œé¢çš„é™æ€å‡½æ•°
    //     io::stdin().read_line( &mut guess).expect("æ— æ³•è¯»å–è¡Œ");
    //     // guess.trim()æŠŠæ¢è¡Œç¬¦,ç©ºæ ¼éƒ½å»æ‰ï¼Œparse()æŠŠå­—ç¬¦ä¸²è§£ææˆæŸç§æ•°å­—ç±»å‹
    //     let guess_new: u32 = match guess.trim().parse() {
    //         // Result æœ‰ä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªæ˜¯Ok,å¦ä¸€ä¸ªæ˜¯é”™è¯¯ä¿¡æ¯
    //         Ok(num) => num,
    //         Err(_) => continue,
    //     };

    //     println!("æ‚¨çŒœæµ‹çš„æ•°å€¼æ˜¯: {}", guess_new);
    //     match guess_new.cmp(&secret_num) {  // cmp å†…ç½®æ–¹æ³•ï¼Œæ˜¯æ¯”è¾ƒå¤§å°
    //         Ordering::Less => println!("Too small!"),
    //         Ordering::Greater => println!("Too big!"),
    //         Ordering::Equal => {
    //             println!("You win!");
    //             break;
    //         }
    //     }
    // }
    // let test_num: u32 = "42".parse().expect("Not a number/");
    // println!("{}", test_num);

    /* æ ‡é‡ç±»å‹ */ 
        // æ•´æ•°ç±»å‹ï¼šæ²¡æœ‰å°æ•°éƒ¨åˆ†ï¼Œé»˜è®¤ç±»å‹å°±æ˜¯i32
            //  u32ï¼š ä¸€ä¸ªæ— ç¬¦å·çš„æ•´æ•°ç±»å‹ï¼Œå æ®32ä½çš„ç©ºé—´
            //  æ— ç¬¦å·æ•´æ•°ç±»å‹ä»¥Uå¼€å¤´  æ²¡æœ‰è´Ÿæ•°
            //  æœ‰ç¬¦å·æ•´æ•°ç±»å‹ä»¥iå¼€å¤´  æœ‰æ­£æœ‰è´Ÿ
        // æµ®ç‚¹ç±»å‹ï¼šå«æœ‰å°æ•°éƒ¨åˆ†çš„ç±»å‹
            // f32ï¼Œ32ä½ï¼Œå•ç²¾åº¦
            // f64ï¼Œ64ä½ï¼ŒåŒç²¾åº¦  é»˜è®¤
        // let x = 2.0;
        // let y: f32 = 3.0;
        // let sum = 5 + 10;
        // let difference = 95.5 - 4.3;
        // let product = 4 * 30;
        // let quotient = 56.7 / 32.2;
        // let reminder = 54 % 5;
        // let x = "z";
        // let y: char = '$';  // è¿™ç§æ–‡å­—éœ€è¦ç”¨å•å¼•å·
        // let x = "ğŸ˜";
    
    /* å¤åˆç±»å‹ */
        // å…ƒç»„ï¼Œå¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œé¢ã€‚é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜
            // let tup = (500, 6.4, 1);
            // println!("{}, {}, {}", tup.0, tup.1, tup.2);
            // // ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥ç»“æ„å…ƒç»„
            // let (x, y, z) = tup;
            // println!("{} | {} | {}", x, y, z)
        // æ•°ç»„ï¼Œå¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œï¼Œä½†æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒï¼Œé•¿åº¦å›ºå®š
            // let list: [i32; 6] = [1,2,3,4,5,6];
            // let a: [i32; 5] = [3;5];  // ç›¸å½“äº let a = [3,3,3,3,3];
            // println!("{}", a[2]);
        // Vector æ¯”æ•°ç»„çµæ´»ï¼Œç”±æ ‡å‡†åº“æä¾›
    // another_fun(5, 6);
    
    // let x = 5;
    // let y = {
    //     let x = 1;
    //     x + 3  // åŠ ä¸Š; è¿™è¡Œä»£ç å°±å˜æˆä¸€ä¸ªè¯­å¥ï¼Œè€Œè¯­å¥æ˜¯æ²¡æœ‰è¿”å›å€¼çš„ï¼Œç›¸å½“äº()
    // };
    // println!("The value of y is : {}", y)

    /* å‡½æ•°çš„è¿”å›å€¼ */
        // åœ¨ -> ç¬¦å·åè¾¹å£°æ˜å‡½æ•°è¿”å›å€¼çš„ç±»å‹ï¼Œä½†æ˜¯ä¸å¯ä¸ºè¿”å›å€¼å‘½å
        // åœ¨Rusté‡Œé¢ï¼Œå‡½æ•°å€¼å°±æ˜¯å‡½æ•°ä½“é‡Œé¢æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
        // è‹¥æ˜¯æƒ³æå‰è¿”å›ï¼Œéœ€è¦ä½¿ç”¨returnå…³é”®å­—ï¼Œå¹¶æŒ‡å®šä¸€ä¸ªå€¼ï¼Œå¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯é»˜è®¤ä½¿ç”¨æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºæœ€åçš„è¿”å›å€¼
        // let x = five(4);
        // println!("è°ƒç”¨å‡½æ•°five: {}", x)

    /* ifè¡¨è¾¾å¼ */
        // æ¡ä»¶å¿…é¡»æ˜¯boolç±»å‹çš„
        // ifè¡¨è¾¾å¼ä¸­ï¼Œä¸æ¡ä»¶ç›¸å…³è”çš„ä»£ç å—å°±å«åšåˆ†æ”¯ï¼ˆarmï¼‰
        // let number = 18;
        // if number < 5 {
        //     println!("å½“è¡¨è¾¾å¼ä¸ºtrue");
        // } else {
        //     println!("å½“è¡¨è¾¾å¼ä¸ºfalse");
        // }
        // å¦‚æœç”¨else if å½“æ»¡è¶³ç¬¬ä¸€ä¸ªåˆ¤æ–­æ—¶ï¼Œå°±ä¸ä¼šå†å¾€ä¸‹èµ°
        // if number % 4 == 0 {
        //     println!("å½“å‰æ•°å­—å¯ä»¥è¢«4æ•´é™¤");
        // } else if number % 3 == 0 {
        //     println!("å½“å‰æ•°å­—å¯ä»¥è¢«3æ•´é™¤");
        // } else if number % 2 == 0 {
        //     println!("å½“å‰æ•°å­—ä¸å¯ä»¥è¢«4,3,2æ•´é™¤");
        // } else {
        //     println!("å½“å‰æ•°å­—å¯ä»¥è¢«2æ•´é™¤");
        // }
        // å¦‚æœä½¿ç”¨å¤šä¸ªelse ifï¼Œé‚£ä¹ˆæœ€å¥½ä½¿ç”¨matchæ¥é‡æ„ä»£ç 
        // match number {
        //     // næ˜¯ä¸€ä¸ªæ¨¡å¼å˜é‡,åœ¨æ¯ä¸ªåˆ†æ”¯ä¸­ï¼Œnéƒ½ä»£è¡¨äº†è¢«åŒ¹é…åˆ°çš„æ•°å­—å€¼
        //     n if n % 4 == 0 => println!("å½“å‰æ•°å­—å¯ä»¥è¢«4æ•´é™¤"),
        //     n if n % 3 == 0 => println!("å½“å‰æ•°å­—å¯ä»¥è¢«3æ•´é™¤"),
        //     n if n % 2 == 0 => println!("å½“å‰æ•°å­—å¯ä»¥è¢«2æ•´é™¤"),
        //     // _æ˜¯é€šé…ç¬¦ï¼Œæ‰€æœ‰ä¸ç¬¦åˆä¸Šè¿°æ¡ä»¶çš„éƒ½ä¼šèµ°_è¿™ä¸ªåˆ†æ”¯
        //     _ => println!("å½“å‰æ•°å­—å¯ä»¥è¢«2æ•´é™¤"),
        // }
        // let condition = true;
        // let number = if condition {5} else {6};
        // println!("æœ€ç»ˆå¾—åˆ°æ•°å­—ï¼š{}", number);

    /* Rustå¾ªç¯ */
        // rustæä¾›äº†3ç§å¾ªç¯ï¼Œloop, while, for

        // loop, å‘Šè¯‰Ruståå¤çš„æ‰§è¡Œä¸€å—ä»£ç ï¼Œç›´åˆ°è§¦å‘åœæ­¢æ¡ä»¶ï¼Œæ‰€ä»¥åœ¨å¾ªç¯é‡Œå¯ä»¥ç”¨breakå…³é”®å­—æ¥å‘Šè¯‰ç¨‹åºåˆé€‚åœæ­¢å¾ªç¯
            // let mut counter = 0;
            // let result = loop {
            //     counter += 1;
            //     if counter == 10 {
            //         break counter * 2;
            //     }
            // };
            // println!("æœ€ç»ˆçš„æ•°å­—ç»“æœä¸º: {}", result)

        // while æ¡ä»¶å¾ªç¯ï¼Œæ¯æ¬¡æ‰§è¡Œå¾ªç¯ä½“ä¹‹å‰éƒ½åˆ¤æ–­ä¸€æ¬¡æ¡ä»¶
            // let mut number = 3;
            // while number != 0 {
            //     println!("number æ•°å€¼: {}", number);
            //     number = number - 1;
            // }
            // println!("å¾ªç¯ç»“æŸï¼")
            
            // let alist = [10, 20, 30, 40, 50, 60];
            // let mut index = 0;
            // // å¯¹äºé›†åˆçš„éå†ï¼Œä¸‹é¢çš„æ–¹æ³•æ‰§è¡Œä¼šæ¯”è¾ƒæ…¢ï¼Œå› ä¸ºæ¯æ¬¡å¾ªç¯éƒ½è¦åˆ¤æ–­ä¸€ä¸‹ï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨forå¾ªç¯
            // while index < alist.len() {
            //     println!("è·å–åˆ°listå€¼ä¸º {}", alist[index]);
            //     index = index + 1;
            // }

        // forå¾ªç¯ï¼Œå¯ä»¥é’ˆå¯¹é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œä¸€äº›ä»£ç 
            // let alist = [10, 20, 30, 40, 50, 60];
            // for e in alist.iter() {
            //     println!("å€¼ä¸º: {}", e)
            // }

        // range å¾ªç¯ï¼Œæ ‡å‡†åº“ï¼Œåˆ¶å®šä¸€ä¸ªå¼€å§‹æ•°å­—å’Œä¸€ä¸ªç»“æŸæ•°å­—ï¼Œrangeå¯ä»¥ç”Ÿæˆä¹‹é—´çš„æ•°å­—ï¼ˆä¸åŒ…å«ç»“æŸï¼‰ï¼Œrevæ–¹æ³•å¯ä»¥åè½¬range
            // for n in (1..4).rev() {  // ç”¨äº†revæ˜¯å€’åºï¼Œ3.2.1
            //     println!("æ•°å­—: {}", n);
            // }
            // println!("å¾ªç¯ç»“æŸ")

    /* æ‰€æœ‰æƒ */
        // rustçš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
        // æ‰€æœ‰ç¨‹åºè¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†å®ƒä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼ 
        // æœ‰äº›è¯­è¨€æœ‰åƒåœ¾æ”¶é›†æœºåˆ¶ï¼ˆJavaã€C#ã€Pythonï¼‰ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œå®ƒä»¬ä¼šä¸æ–­åœ°å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ï¼Œä½†æ˜¯ä¼šå¸¦æ¥ä¸€äº›æ€§èƒ½å¼€é”€
        // åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜

        // rusté‡‡ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼
            // å†…å­˜æ˜¯é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†ï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
            // å½“ç¨‹åºè¿è¡Œæ—¶ï¼Œæ‰€æœ‰æƒç‰¹æ€§ä¸ä¼šå‡æ…¢ç¨‹åºçš„è¿è¡Œé€Ÿåº¦ 

        // æ ˆå†…å­˜ï¼ˆstackï¼‰å’Œ å †å†…å­˜ï¼ˆheapï¼‰
            // åœ¨rustä¸­ï¼Œä¸€ä¸ªå€¼æ˜¯åœ¨stackä¸Šè¿˜æ˜¯åœ¨heapä¸Šå¯¹è¯­è¨€çš„è¡Œä¸ºå’Œä½ ä¸ºä»€ä¹ˆè¦åšæŸäº›å†³å®šæ˜¯æœ‰æ›´å¤§å½±å“çš„
            // stackï¼ŒæŒ‰ç…§å€¼çš„æ¥æ”¶é¡ºåºæ¥å‚¨å­˜ï¼ŒæŒ‰ç›¸åçš„é¡ºåºå°†å®ƒä»¬ç§»é™¤ï¼ˆåè¿›å…ˆå‡ºï¼ŒLIFOï¼‰
                // -æ·»åŠ æ•°æ®å« å‹å…¥æ ˆ
                // -ç§»é™¤æ•°æ®å« å¼¹å‡ºæ ˆ
                // æ‰€æœ‰å­˜å‚¨åœ¨stackä¸Šçš„æ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥çš„å›ºå®šçš„å¤§å°ï¼Œç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„æ•°æ®æˆ–è¿è¡Œæ—¶å¤§å°å¯èƒ½å‘ç”Ÿå˜åŒ–çš„æ•°æ®å¿…é¡»å­˜æ”¾åœ¨heapä¸Š
            // heapï¼Œå†…å­˜ç»„ç»‡æ€§å·®ä¸€ç‚¹ï¼Œå½“æŠŠæ•°æ®æ”¾å…¥heapæ—¶ï¼Œä¼šè¯·æ±‚ä¸€å®šæ•°é‡çš„ç©ºé—´
                // æ“ä½œç³»ç»Ÿåœ¨heapé‡Œæ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºåœ¨ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªç©ºé—´çš„åœ°å€ï¼Œè¿™ä¸ªè¿‡ç¨‹å«åšåœ¨heapä¸Šè¿›è¡Œåˆ†é…ï¼Œæœ‰æ—¶ä»…ä»…ç§°ä¸ºâ€åˆ†é…â€œ
            // æŠŠå€¼å‹å…¥stackä¸Šä¸å«åˆ†é…ï¼Œå¹¶ä¸”å› ä¸ºæŒ‡é’ˆæ˜¯å·²çŸ¥çš„å›ºå®šå¤§å°çš„ï¼Œå¯ä»¥æŠŠæŒ‡é’ˆå­˜æ”¾åœ¨stackä¸Š
                // å¦‚æœæƒ³è¦å®é™…æ•°æ®ï¼Œå¿…é¡»ä½¿ç”¨æŒ‡é’ˆæ¥å®šä½
            // åœ¨heapä¸Šåˆ†é…ç©ºé—´éœ€è¦åšæ›´å¤šçš„å·¥ä½œï¼Œæ“ä½œç³»ç»Ÿé¦–å…ˆéœ€è¦æ‰¾ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç©ºé—´æ¥å­˜æ”¾æ•°æ®ï¼Œç„¶ååšå¥½è®°å½•æ–¹ä¾¿ä¸‹æ¬¡åˆ†é…
            // è®¿é—®heapä¸­çš„æ•°æ®è¦æ¯”è®¿é—®stackä¸­çš„æ•°æ®æ…¢ï¼Œå› ä¸ºéœ€è¦é€šè¿‡æŒ‡é’ˆæ‰èƒ½æ‰¾åˆ°heapä¸­çš„æ•°æ®ï¼Œå¯¹äºç°ä»£çš„å¤„ç†å™¨æ¥è¯´ï¼Œç”±äºç¼“å­˜çš„ç¼˜æ•…ï¼Œå¦‚æœæŒ‡ä»¤åœ¨å†…å­˜ä¸­è·³è½¬çš„æ¬¡æ•°è¶Šå°‘ï¼Œé‚£ä¹ˆé€Ÿåº¦å°±è¶Šå¿«
            // å¦‚æœæ•°æ®å­˜æ”¾çš„è·ç¦»æ¯”è¾ƒè¿‘ï¼Œé‚£ä¹ˆå¤„ç†å™¨çš„å¤„ç†é€Ÿåº¦å°±ä¼šæ›´å¿«ä¸€äº›ï¼ˆstackä¸Šï¼‰
            // å¦‚æœæ•°æ®ä¹‹é—´çš„è·ç¦»æ¯”è¾ƒè¿œï¼Œé‚£ä¹ˆå¤„ç†é€Ÿåº¦å°±ä¼šæ…¢ä¸€äº›ï¼ˆheapä¸Šï¼‰åœ¨heapä¸Šåˆ†é…å¤§é‡çš„ç©ºé—´ä¹Ÿæ˜¯éœ€è¦æ—¶é—´çš„

        // æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜ï¼š
            // 1. è·Ÿè¸ªä»£ç çš„é‚£äº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨heapçš„é‚£äº›æ•°æ®
            // 2. æœ€å°åŒ–heapä¸Šçš„é‡å¤æ•°æ®é‡
            // 3. æ¸…ç†heapä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³
            // æ‰€ä»¥ï¼Œç®¡ç†heapæ•°æ®å°±æ˜¯æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› 

        // æ‰€æœ‰æƒçš„è§„åˆ™
            // æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯æ³•æ²»çš„æ‰€æœ‰è€…
            // æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
            // å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤
        // ä½œç”¨åŸŸ
            // fn dd() {
            //     // s ä½œç”¨åŸŸä¸å¯ç”¨
            //     let s = "hello";  // s å¯ç”¨
            //     // å¯ä»¥å¯¹sè¿›è¡Œç›¸å…³æ“ä½œ
            // }  // s ä½œç”¨åŸŸåˆ°æ­¤ç»“æŸï¼Œs ä¸å¯å†ç”¨
            
        /* å‡½æ•°è°ƒç”¨ */
            // å½“ä»£ç è°ƒç”¨å‡½æ•°æ—¶ï¼Œå€¼è¢«ä¼ å…¥åˆ°å‡½æ•°ï¼ˆä¹ŸåŒ…æ‹¬æŒ‡å‘heapçš„æŒ‡é’ˆï¼‰ï¼Œå‡½æ•°æœ¬åœ°çš„å˜é‡è¢«å‹å€’stackä¸Šï¼Œå½“å‡½æ•°ç»“æŸåï¼Œè¿™äº›å€¼å°±ä»stackä¸Šå¼¹å‡º
        
        // stringç±»å‹ï¼Œæ¯”åŸºç¡€æ ‡é‡æ•°æ®ç±»å‹æ›´å¤æ‚ï¼Œæ‰€ä»¥åœ¨æ­¤ä»¥stringç±»å‹ä¸¾ä¾‹ä½¿ç”¨æ‰€æœ‰æƒ 
            // åˆ›å»ºstringç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨fromå‡½æ•°ä»å­—ç¬¦ä¸²å­—é¢å€¼åˆ›å»ºå‡ºstringç±»å‹
            // let mut str_info = String::from("hello");  // :: è¡¨ç¤ºfromæ˜¯Stringç±»å‹ä¸‹çš„å‡½æ•°
            // str_info.push_str(", World!");
            // println!("{}", str_info);

            // let str_info = "hello";  
            // let str_info2 = "hello";  
            // let str_info3 = str_info.to_owned() + str_info2;  // .to_owned() æ–¹æ³•ä¼šåœ¨å †ä¸Šåˆ†é…å†…å­˜,å¹¶å°† &str çš„å†…å®¹å¤åˆ¶åˆ°æ–°åˆ†é…çš„ String ä¸­
            // println!("{}", str_info3);
            // å½“èµ°å‡ºä½œç”¨åŸŸæ˜¯ï¼Œrustä¼šè‡ªåŠ¨è°ƒç”¨dropè¿™ä¸ªå‡½æ•°

        /* å˜é‡å’Œæ•°æ®äº¤äº’çš„æ–¹å¼ï¼š ç§»åŠ¨ï¼ˆmoveï¼‰ */
            // å› ä¸ºæ•´æ•°æ‹¥æœ‰copy traitï¼Œä¹Ÿå°±æ˜¯è¯´æ‰€æœ‰çš„éƒ½åœ¨stackä¸Šï¼Œæ‰€ä»¥å¤åˆ¶ä¹‹åä¹‹å‰çš„æ˜¯å¯ä»¥ä½¿ç”¨çš„
                // let x = 5;
                // let y = x;
                // println!("{}, {}", x, y)  // æ­¤æ—¶ä¸ä¼šæŠ¥é”™ï¼Œç”±äºæ•´æ•°æ˜¯å·²çŸ¥ä¸”å›ºå®šå¤§å°çš„ç®€å•çš„å€¼ï¼Œè¿™ä¸¤ä¸ª5è¢«å‹åˆ°äº†stackä¸­ï¼Œæ‰€ä»¥ä¸éœ€è¦é‡Šæ”¾
            // å­—ç¬¦ä¸²ç±»å‹åªæœ‰ä¸€éƒ¨åˆ†åœ¨stackä¸Šï¼ˆæŒ‡é’ˆï¼‰ï¼Œæ‰€ä»¥å¤åˆ¶ä¹‹åï¼Œä¹‹å‰çš„åœ¨stackä¸Šçš„å°±ä¼šå¤±æ•ˆï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰æƒè¢«è½¬ç§»
                // let s1 = String::from("æˆ‘æ˜¯åœ¨stackä¸Šçš„ï¼Œæˆ‘çš„æ•°æ®åˆ™å­˜æ”¾åœ¨heapä¸Š");
                // let s2 = s1;  // æ­¤æ—¶ï¼Œs2å¤åˆ¶äº†ä¸€ä»½s1åœ¨stackä¸Šçš„æ•°æ®ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æŠŠheapä¸Šçš„æ•°æ®åŠ è½½è¿›æ¥ï¼Œå¹¶ä¸”æ­¤æ—¶s1å·²ç»å¤±æ•ˆ
                // println!("{}", s1)  // æ‰€ä»¥æ­¤æ—¶å¦‚æœå†å°è¯•æ‰“å°s1ï¼Œå°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºs1çš„æ‰€æœ‰æƒè¢«è½¬ç§»åˆ°äº†s2
            // ä¸€äº›æ‹¥æœ‰Copy traitçš„ç±»å‹
                // ä»»ä½•ç®€å•æ ‡é‡çš„ç»„åˆç±»å‹éƒ½å¯ä»¥Copyçš„
                // ä»»ä½•éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§èµ„æºçš„éƒ½ä¸æ˜¯Copyçš„
                // ä¾‹å¦‚ï¼š
                    // æ‰€æœ‰çš„æ•´æ•°ç±»å‹ï¼Œu32...
                    // bool
                    // char
                    // æ‰€æœ‰çš„æµ®ç‚¹ç±»å‹ f64...
                    // Tuple(å…ƒç»„),å¦‚æœé‡Œé¢æ‰€æœ‰çš„å­—æ®µéƒ½æ˜¯Copyçš„
                        // (i32,f64)æ˜¯
                        // (i32, String)ä¸æ˜¯

        /* æ‰€æœ‰æƒä¸å‡½æ•° */
            // å‡½æ•°çš„å…¥å‚
                // let s = String::from("æˆ‘æ˜¯å­—ç¬¦ä¸²");
                // take_own(s);   // så·²ç»å°†æ‰€æœ‰æƒç§»åŠ¨åˆ°è¿™ä¸ªå‡½æ•°çš„å‚æ•°äº†
                // // println!("{}", s)  // æ­¤æ—¶sçš„æ‰€æœ‰æƒä¸€å€ç§»äº¤ç»™take_ownï¼Œæ‰€ä»¥æ— æ³•å†è°ƒç”¨s
                // let x = 4;
                // make_copy(x);
                // println!("å°†xä¼ å…¥å‡½æ•°ä¹‹å,ä»ç„¶èƒ½è°ƒç”¨x{}", x);

            // å‡½æ•°çš„è¿”å›å€¼ä¸ä½œç”¨åŸŸ
                // å‡½æ•°å­å•Šè¿”å›å€¼çš„è¿‡ç¨‹ä¸­åŒæ ·ä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»
                // ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼ï¼šæŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶ä»–å˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨ï¼Œå½“ä¸€ä¸ªåŒ…å«heapæ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢«dropå‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†
                    // let s1 = gives_own();
                    // let s2 = String::from("New");
                    // let s3 = takes_and_give_back(s2);
                    // println!("\n S1: {}, S3: {}, S2è¢«ç§»äº¤,æ— æ³•å†è°ƒç”¨\n", s1, s3)
                // å¦‚æœ æƒ³è¦å‡½æ•°ä½¿ç”¨æŸä¸ªå€¼ï¼Œä½†æ˜¯ä¸è·å¾—å…¶æ‰€æœ‰æƒï¼Œå°±éœ€è¦ä½¿ç”¨å®Œä¹‹åï¼Œå°†å€¼è¿”å›
                    // let ss1 = String::from("æˆ‘æ˜¯SS1");
                    // let (ss2, lens) = calculate_length(ss1);
                    // println!("\nå½“å‰å­—ç¬¦ä¸²ä¸º: {}, å­—ç¬¦ä¸²çš„é•¿åº¦ä¸º: {}\n", ss2, lens)
            
            // å¼•ç”¨å’Œå€Ÿç”¨
                // å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªé‡è¦çš„é™åˆ¶ï¼Œåœ¨ç‰¹å®šä½œç”¨åŸŸå†…ï¼Œå¯¹æŸä¸€å—æ•°æ®ï¼Œåªèƒ½æœ‰ä¸€ä¸ªå¯å˜çš„å¼•ç”¨ï¼Œè¿™æ ·åœ¨å¯ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰
                    // let mut s4 = String::from("å‡½æ•°çš„å¼•ç”¨");
                    // let lens = calculate_length(&mut s4);
                    // println!("\nå­—ç¬¦ä¸²é•¿åº¦: {}\n", lens)
                // æ•°æ®ç«äº‰ä¼šå‡ºç°ä»¥ä¸‹ä¸‰ç§åœºæ™¯
                    // 1. ä¸¤ä¸ªæˆ–å¤šä¸ªæŒ‡é’ˆåŒæ—¶è®¿é—®åŒä¸€ä¸ªæ•°æ®
                    // 2. è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆç”¨äºå†™å…¥æ•°æ®
                    // 3. æ²¡æœ‰ä½¿ç”¨ä»»ä½•æœºåˆ¶æ¥åŒæ­¥å¯¹æ•°æ®çš„è®¿é—®
                        // let mut a1 = String::from("A1");
                        // let a2 = &mut a1;
                        // // {
                        // //     let a2 = &mut a1;
                        // //     println!("A2: {}", a2);
                        // // }
                        // let a3 = &mut a1;  // åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸï¼Œåœ¨å·²ç»æŠŠa1å€Ÿå‡ºå»ä¹‹åï¼Œä¸èƒ½å†å€Ÿç»™å¦å¤–çš„å˜é‡ï¼Œæ‰€ä»¥è¿™é‡Œä¼šæŠ¥é”™
                        // println!("A2: {}, A3: {}", a2, a3);  
                // ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€ä¸ªä¸å˜çš„å¼•ç”¨ï¼Œæœ‰ä»¥ä¸‹åŸå› 
                    // æ•°æ®ç«äº‰ï¼šå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®ç›¸åŒçš„æ•°æ®ï¼Œå…¶ä¸­ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œå†™æ“ä½œï¼Œè€Œå…¶ä»–çº¿ç¨‹è¿›è¡Œè¯»æ“ä½œï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ä¸ä¸€è‡´æˆ–è€…å…¶ä»–æ„å¤–çš„ç»“æœã€‚
                    // å†…å­˜ä¸ä¸€è‡´ï¼šç”±äºå¯å˜å¼•ç”¨å…è®¸ä¿®æ”¹æ•°æ®ï¼Œè€Œä¸å¯å˜å¼•ç”¨ä¸å…è®¸ä¿®æ”¹æ•°æ®ï¼Œè¿™å¯èƒ½å¯¼è‡´æ•°æ®åœ¨ä¸åŒçš„å¼•ç”¨ä¹‹é—´ä¸ä¸€è‡´ã€‚
                        // let mut sq = String::from("å¯å˜æ•°æ®");
                        // println!("{}", sq);
                        // sq.push_str("string");
                        // let r1 = &mut sq;
                        // println!("R1: {}", r1);
                        // let r2 = &sq;
                        // println!("R2: {}", r2);
                        // // println!("R1: {}, R2: {}", r1, r2)
                // æ‚¬ç©ºå¼•ç”¨
                    // æ‚¬ç©ºæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆå¼•ç”¨äº†å†…å­˜ä¸­çš„æŸä¸ªåœ°å€ï¼Œè€Œè¿™å—å†…å­˜å¯èƒ½å·²ç»é‡Šæ”¾å¹¶åˆ†é…ç»™å…¶ä»–äººä½¿ç”¨äº†
                // å¼•ç”¨çš„è§„åˆ™ï¼Œåœ¨ä»»ä½•ç»™å®šçš„æ—¶åˆ»ï¼Œåªèƒ½æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ä¹‹ä¸€
                    // ä¸€ä¸ªå¯å˜çš„å¼•ç”¨
                    // ä»»æ„æ•°é‡ä¸å¯å˜çš„å¼•ç”¨
                    // å¼•ç”¨å¿…é¡»ä¸€ç›´æœ‰æ•ˆ 
            
            // rustå¦å¤–ä¸€ç§ä¸æ”¯æŒæ‰€æœ‰æƒçš„æ•°æ®ç±»å‹ï¼Œåˆ‡ç‰‡
                // let mut s1 = String::from("ä½ å¥½ ä¸­å›½");
                // let w = first_world(&mut s1);
                // println!("{}", w);
                // s1 = format!("{}, Rust", s1);
                // println!("{}", s1)
                // let hello = &s1[..5];
                // println!("{}", hello);
                // let word = &s1[6..];
                // println!("{}", word);
                // let whole = &s1[..];
                // println!("{}", whole);
                // let word_index = first_world(&s1);
                // println!("{}", word_index)

                // let w1 = String::from("hi ä½ å¥½");
                // let word = first_world(&w1[..]);
                // println!("{}", word);
                // let w2 = "heihei n";
                // let word2 = first_world(w2);
                // println!("{}", word2);
         
         /* struct */
            // ä½¿ç”¨structå…³é”®å­—ï¼Œå¹¶ä¸ºæ•´ä¸ªstructå‘½å 
                // println!("ç°åœ¨æ˜¯structæ¨¡å—");
                // // ä¸€æ—¦structçš„å®ä¾‹æ˜¯å¯å˜çš„ï¼Œé‚£ä¹ˆå®ä¾‹ä¸­æ‰€æœ‰çš„å­—æ®µéƒ½æ˜¯å¯å˜çš„
                // let mut user = User {
                //     username: String::from("Beriuta"),
                //     email: String::from("abc@123.com"),
                //     active:true,
                // };
                // user.email = String::from("sdwdve@456.com");
                // user.username = String::from("å°æ³¼çŒ´");
                // user.active = false;
                // println!("{:?}", user);
                // let user2 = User {
                //     username: String::from("å°ç‰›"),
                //     email: String::from("xiaoniu@123.com"),
                //     ..user
                // };
                // println!("{:?}", user2);
            // Tuple struct
                // æ•´ä½“æœ‰ä¸ªåï¼Œä½†é‡Œé¢çš„å…ƒç´ æ²¡æœ‰å
                // é€‚ç”¨äºï¼Œåƒä¸ªæ•´ä¸ªtupleèµ·åï¼Œå¹¶è®©å®ƒä¸å±äºå…¶ä»–tupleï¼Œè€Œä¸”åˆä¸éœ€è¦ç»™æ¯ä¸ªå…ƒç´ èµ·å
                    // let black = Color (1,2,3);
                    // let origin = Point (11,22,33);
                    // println!("{:?}", black);
                    // println!("{:?}", origin);
                    // println!("Colorç¬¬äºŒä¸ª: {}", black.1);
                    // println!("Pointç¬¬äºŒä¸ª: {}", origin.1);
                // black å’Œ origin æ˜¯ä¸åŒçš„ç±»å‹ï¼Œæ˜¯ä¸æ˜¯çš„tuple structçš„å®ä¾‹
            // struct æ“ä½œ
                // let w = 30;
                // let l = 50;
                // println!("{}", area(w, l))
                // let rect = (30,50);
                // println!("{}", area(rect));
                // let rect = Rectangle {
                //     width: 30,
                //     length: 50,
                // };
                // println!("{}",area(&rect));
                // println!("{:#?}",rect) // ç»“æ„ä½“æ·»åŠ #[derive(Debug)]ï¼Œå¯ä»¥æ‰“å°å‡ºè§‚çœ‹å‹å¥½çš„æ ¼å¼
            // structæ–¹æ³•ä¸å…³è”å‡½æ•°
                // æ–¹æ³•å’Œå‡½æ•°ç±»ä¼¼ï¼šfnå…³é”®å­—ï¼Œåç§°ï¼Œå‚æ•°ï¼Œè¿”å›å€¼
                // æ–¹æ³•ä¸å‡½æ•°ä¸åŒä¹‹å¤„ï¼š
                    // æ–¹æ³•æ˜¯åœ¨structï¼ˆæˆ–enumï¼Œtraitå¯¹è±¡ï¼‰çš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰
                    // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯selfï¼Œè¡¨ç¤ºæ–¹æ³•è¢«è°ƒç”¨çš„structå®ä¾‹,åœ¨å®šä¹‰æ–¹æ³•æ˜¯ï¼Œè¦æœ‰å…³é”®å­—implï¼Œæ–¹æ³•è¦åœ¨å—é‡Œé¢å®šä¹‰
                        // let rect = Rectangle {
                        //     width: 30,
                        //     length: 50,
                        // };
                        // println!("{}",rect.area());
                // æ–¹æ³•è°ƒç”¨çš„è¿ç®—ç¬¦
                    // c++/c é‡Œé¢çš„æ–¹æ³•è°ƒç”¨ï¼š object->something() å’Œ (*object).something()ä¸€æ ·
                    // rustæ²¡æœ‰->è¿ç®—ç¬¦
                        // åœ¨è°ƒç”¨æ–¹æ³•æ—¶ï¼Œrustæ ¹æ®æƒ…å†µè‡ªåŠ¨æ·»åŠ &ã€&mut æˆ– * ï¼Œä»¥ä¾¿Objectå¯ä»¥åŒ¹é…æ–¹æ³•çš„ç­¾å
                        // p1.distance(&p2);  == (&p1).distance(&p2);
                    // let rect1 = Rectangle {
                    //         width: 30,
                    //         length: 50,
                    //     };
                    // let rect2 = Rectangle {
                    //     width: 20,
                    //     length: 40,
                    // };
                    // let rect3 = Rectangle {
                    //     width: 60,
                    //     length: 70,
                    // };
                    // println!("1é•¿æ–¹å½¢æ˜¯å¦èƒ½åŒ…å«2é•¿æ–¹å½¢,{}", rect1.can_hold(&rect2));
                    // println!("2é•¿æ–¹å½¢æ˜¯å¦èƒ½åŒ…å«3é•¿æ–¹å½¢,{}", rect2.can_hold(&rect3))
                // å…³è”å‡½æ•°ï¼Œå¯ä»¥åœ¨implå—ä¸­å®šä¹‰ï¼Œä¸æŠŠselfä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œæ³¨æ„ï¼šä¸æ˜¯æ–¹æ³•ï¼Œ ä¾‹å¦‚ï¼šString::from()
                    // å…³è”å‡½æ•°é€šå¸¸ç”¨äºæ„é€ å™¨ 
                        // :: 1. ç¬¦å·æ˜¯è°ƒç”¨å…³è”å‡½æ•°  2. æ¨¡å—åˆ›å»ºçš„å‘½åç©ºé—´
                        // let s = Rectangle::square(50);
                        // println!("{:#?}", s);
        /* æšä¸¾ä¸æ¨¡å¼åŒ¹é… */  
            // æšä¸¾ï¼šå…è®¸æˆ‘ä»¬åˆ—ä¸¾æ‰€æœ‰å¯èƒ½çš„å€¼æ¥å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œç”¨enumå…³é”®å­—
                // let four = IpAddrKind::Ipv4;
                // let six = IpAddrKind::Ipv6;
                // route(four);
                // route(six);
                // route(IpAddrKind::Ipv4);

                // æšä¸¾ç±»å‹å¯ä»¥ä½œä¸ºstructå†…çš„å­—æ®µç±»å‹
                    // let home = IpAddr {
                    //     kind: IpAddrKind::Ipv4,
                    //     address: String::from("127.0.0.1"),
                    // };
                    // let loopback = IpAddr {
                    //     kind: IpAddrKind::Ipv6,
                    //     address: String::from("::1"),
                    // };
                // å°†æ•°æ®é™„åŠ åˆ°æšä¸¾çš„å˜ä½“ä¸­
                    // let home = IpAddrKind::V4(127, 0, 0, 1);
                    // let loopback = IpAddrKind::V6(String::from("::1"));
                    // let q = Message::Quit;
                    // let m = Message::Move { x: 12, y: 13 };  // åŒ¿åç»“æ„ä½“
                    // let w = Message::Write(String::from("Hello!"));
                    // let c = Message::ChangeColor(0, 255, 255);
                // ç»™æšä¸¾å®šä¹‰æ–¹æ³•
                    // m.call();
                    // w.call();
                    // c.call();
            // Option æšä¸¾
                // å®šä¹‰äºæ ‡å‡†åº“ä¸­ï¼Œåœ¨Preludeï¼ˆé¢„å¯¼å…¥æ¨¡å—ï¼‰ä¸­ï¼Œæè¿°äº†ï¼ŒæŸä¸ªå€¼å¯èƒ½å­˜åœ¨ï¼ˆæŸç§ç±»å‹ï¼‰æˆ–ä¸å­˜åœ¨çš„æƒ…å†µ
                // rustæ²¡æœ‰nullï¼Œæ‰€ä»¥rustä¸­ç±»ä¼¼nullæ¦‚å¿µçš„æšä¸¾ ï¼š Option<T>
                    // let some_number = Some(5);
                    // let some_string = Some("A string");
                    // let absent_number: Option<i32> = None;
            // match æ§åˆ¶æµè¿ç®—ç¬¦
                // å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
                // æ¨¡å¼å¯ä»¥æ˜¯å­—é¢å€¼ã€å˜é‡åã€é€šé…ç¬¦...
                    // let c = Coin::Penny;
                    // value_in_coin(c);
            // ç»‘å®šå€¼çš„æ¨¡å¼
                // åŒ¹é…çš„åˆ†æ”¯å¯ä»¥ç»‘å®šåˆ°è¢«åŒ¹é…å¯¹è±¡çš„éƒ¨åˆ†å€¼ï¼Œå› æ­¤å¯ä»¥ä»enumå˜ä½“ä¸­æå–å€¼
                    // let c = Coin::Quarter(UsState::Alaska);
                    // println!("{}", value_in_coin(c));
                    // let c2 = Coin::Quarter(UsState::Alabama);
                    // println!("{}", value_in_coin(c2));
            // Option<T>
                // let five = Some(5);
                // let six = plus_one(five);
                // let none = plus_one(None);
                // println!("{}", six.unwrap_or(-1));  // unwrap_or æ­¤æ–¹æ³•æ˜¯è·å–å½“å‰æšä¸¾çš„å€¼ï¼Œå¦‚æœæœ‰å€¼å°±æ‰“å°åŸæœ¬çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å°±æ‰“å°é»˜è®¤å€¼-1
                // println!("{}", none.unwrap_or(-1))
            // matchåŒ¹é…å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„å¯èƒ½ï¼Œå¦‚æœæœ‰å¾ˆå¤šæ²¡å¿…è¦ç©·ä¸¾çš„ï¼Œå¯ä»¥ä½¿ç”¨_é€šé…ç¬¦æ¥æ›¿ä»£å…¶ä½™æ²¡åˆ—å‡ºæ¥çš„å€¼
                // let v = 10;
                // match v {
                //     1 => println!("one"),
                //     5 => println!("five"),
                //     8 => println!("eight"),
                //     10 => println!("ten"),
                //     _ => println!("nothing"),
                // }
            // if let:  
                // å¤„ç†ç›´æŒ‚æ‚¨ä¸€ç§åŒ¹é…è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µ,ä½†æ˜¯ï¼Œä½¿ç”¨äº†if let å°±æ”¾å¼ƒäº†ç©·ä¸¾ï¼Œå¯ä»¥æŠŠif letçœ‹ä½œæ˜¯matchçš„è¯­æ³•ç³–
                    // let v = Some(3u8);
                    // println!("{:?}", &v);
                    // if let Some(3) = v {
                    //     println!("three")
                    // }
                // ä¹Ÿå¯ä»¥æ­é…elseä½¿ç”¨
                    // let vv = Some(76u8);
                    // if let Some(76) = vv {
                    //     println!("æ•°å­—ä¸º76")
                    // } else {
                    //     println!("others")
                    // }
        /* Rustçš„ä»£ç ç»„ç»‡ */
            // ä»£ç ç»„ç»‡ä¸»è¦åŒ…æ‹¬
                // é‚£äº›ç»†èŠ‚æ˜¯å¯ä»¥æš´éœ²ï¼Œé‚£äº›ç»†èŠ‚æ˜¯ç§æœ‰çš„
                // ä½œç”¨åŸŸå†…å“ªäº›åç§°æœ‰æ•ˆç­‰
            // æ¨¡å—ç³»ç»Ÿï¼ˆç­‰çº§ä¾æ¬¡å¾€ä¸‹ï¼‰
                // Package(åŒ…)æœ€é¡¶å±‚ï¼šCargoç‰¹æ€§ï¼Œæ„å»ºï¼Œæµ‹è¯•ï¼Œå…±äº«crate
                // Crateï¼ˆå•å…ƒåŒ…ï¼‰ï¼šä¸€ä¸ªæ¨¡å—æ ‘ï¼Œå®ƒå¯äº§ç”Ÿä¸€ä¸ªlibraryï¼ˆåº“ï¼‰æˆ–å¯æ‰§è¡Œæ–‡ä»¶
                // Moduleï¼ˆæ¨¡å—ï¼‰ï¼šä½¿ç”¨æ—¶è¦ç”¨useï¼šå…³é”®å­—ï¼Œè®©ä½ æ§åˆ¶ä»£ç çš„ç»„ç»‡ï¼Œä½œç”¨åŸŸï¼Œç§æœ‰è·¯å¾„
                // Pathï¼ˆè·¯å¾„ï¼‰ï¼š ä¸ºstructï¼Œfunctionæˆ–moduleç­‰é¡¹å‘½åçš„æ–¹å¼
            // Crateç±»å‹ï¼š
                // binaryï¼šäºŒè¿›åˆ¶
                // libraryï¼šåº“
            // Crate Rootï¼ˆæ ¹ï¼‰ï¼š
                // æ˜¯æºä»£ç æ–‡ä»¶
                // Rustç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹ï¼Œç»„æˆä½ çš„Crateçš„æ ¹Module
            // Cargoçš„æƒ¯ä¾‹ï¼ˆè¿™ä¸¤ä¸ªéƒ½æ˜¯å…¥å£æ–‡ä»¶ï¼‰
                // src/main.rs äºŒè¿›åˆ¶çš„crate
                    //  binary crate çš„crate root
                    // crate åä¸packageåç›¸åŒ
                // src/lib.rs   åº“crate
                    // packageåŒ…å«ä¸€ä¸ªlibrary crate
                    // library crate çš„crate root
                    // crateåä¸packageåç›¸åŒ
                // Cargoä¼šæŠŠcrate root æ–‡ä»¶äº¤ç»™rustc æ¥æ„å»ºlibraryæˆ–binary
                
            // Package
                // åŒ…å«ä¸€ä¸ªCargo.toml,å®ƒæè¿°äº†å¦‚ä½•æ„å»ºè¿™äº›Crates
                // åªèƒ½åŒ…å«0-1ä¸ªlibrary crate
                // å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„binary crate
                // ä½†å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ªcrateï¼ˆlibrary æˆ– binaryï¼‰
                // ä¸€ä¸ªPackageå¯ä»¥åŒæ—¶åŒ…å«src/main.rs å’Œ src/lib.rs
                    // ä¸€ä¸ªbinary crateï¼Œä¸€ä¸ªlibrary crate
                    // åç§°ä¸Packageåç›¸åŒ
                // ä¸€ä¸ªPackageå¯ä»¥æœ‰å¤šä¸ªbinary crate
                    // æ–‡ä»¶æ”¾åœ¨src/bin
                    // æ¯ä¸ªæ–‡ä»¶æ˜¯å•ç‹¬çš„binary crate
            // Module
                // åœ¨ä¸€ä¸ªcrateå†…ï¼Œå°†ä»£ç è¿›è¡Œåˆ†ç»„
                // å¢åŠ å¯è¯»æ€§ï¼Œæ˜“äºå¤ç”¨
                // æ§åˆ¶é¡¹ç›®ï¼ˆitemï¼‰çš„ç§æœ‰æ€§ï¼Œpublicï¼Œ private
            // å»ºç«‹Module
                // mod å…³é”®å­—
                // å¯åµŒå¥—
                // å¯åŒ…å«å…¶ä»–é¡¹ï¼ˆstructï¼Œ enumï¼Œå¸¸é‡ï¼Œ traitï¼Œå‡½æ•°ç­‰ï¼‰çš„å®šä¹‰
            // è·¯å¾„ï¼ˆPathï¼‰
                // ä¸ºäº†åœ¨Rustçš„æ¨¡å—ä¸­æ‰¾åˆ°æŸä¸ªæ¡ç›®ï¼Œéœ€è¦ä½¿ç”¨è·¯å¾„
                // è·¯å¾„çš„ä¸¤ç§å½¢å¼
                    // ç»å¯¹è·¯å¾„: ä»crate rootå¼€å§‹ï¼Œä½¿ç”¨crateåæˆ–å­—é¢å€¼crate
                    // ç›¸å¯¹è·¯å¾„ï¼šä»å½“å‰æ¨¡å—å¼€å§‹ï¼Œä½¿ç”¨selfï¼ˆæœ¬èº«ï¼‰ï¼Œsuperï¼ˆä¸Šä¸€çº§ï¼‰æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦
                // è·¯å¾„è‡³å°‘ç”±ä¸€ä¸ªæ ‡è¯†ç¬¦ç»„æˆï¼Œæ ‡è¯†ç¬¦ä¹‹é—´ä½¿ç”¨::
            // ç§æœ‰è¾¹ç•Œï¼ˆprivate boundaryï¼‰
                // æ¨¡å—ä¸ä»…å¯ä»¥ç»„ç»‡ä»£ç ï¼Œè¿˜å¯ä»¥å®šä¹‰ç§æœ‰è¾¹ç•Œ
                // å¦‚æœæƒ³æŠŠå‡½æ•°æˆ–structç­‰è®¾ä¸ºç§æœ‰ï¼Œå¯ä»¥å°†å®ƒæ”¾åœ¨æŸä¸ªæ¨¡å—ä¸­
                // Rustä¸­æ‰€æœ‰çš„æ¡ç›®ï¼ˆå‡½æ•°ï¼Œæ–¹æ³•ï¼Œstructï¼Œenumï¼Œæ¨¡å—ï¼Œå¸¸é‡ï¼‰é»˜è®¤æ˜¯ç§æœ‰çš„
                // çˆ¶çº§æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
                // å­æ¨¡å—é‡Œå¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
            // pub å…³é”®å­—
                // ä½¿ç”¨pubå…³é”®å­—å°±å¯ä»¥æŠŠç§æœ‰çš„å˜ä¸ºå…¬å…±çš„
                // pub struct
                    // pubæ”¾åœ¨structå‰ï¼Œstructæ˜¯å…¬å…±çš„
                    // ä½†æ˜¯structçš„å­—æ®µå€¼é»˜è®¤æ˜¯ç§æœ‰çš„
                    // structçš„å­—æ®µéœ€è¦å•ç‹¬è®¾ç½®pubæ¥å˜æˆå…±æœ‰çš„
                // pub enum
                    // enumæ˜¯å…¬å…±çš„ï¼Œenumçš„å˜ä½“ä¹Ÿé»˜è®¤ä¸ºå…¬å…±çš„
            // superå…³é”®å­—
                // ç”¨æ¥è®¿é—®çˆ¶çº§æ¨¡å—è·¯å¾„ä¸­çš„å†…å®¹ï¼Œç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„
            // useå…³é”®å­—
                // å¯ä»¥ä½¿ç”¨useå…³é”®å­—å°†è·¯å¾„å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…ï¼Œä½†æ˜¯ä»ç„¶éµå¾ªç§æœ‰æ€§è§„åˆ™ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªæœ‰å…¬å…±çš„å¯ä»¥ç”¨
                // å‡½æ•°ï¼šæƒ¯ç”¨å°†å‡½æ•°çš„çˆ¶çº§æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼ˆæŒ‡å®šåˆ°çˆ¶çº§ï¼‰
                // struct, enum, å…¶ä»–ï¼šæŒ‡å®šå®Œæ•´è·¯å¾„ï¼ˆæŒ‡å®šåˆ°æœ¬èº«ï¼‰ä½†æ˜¯å¦‚æœä¸åŒåŒ…å†…çš„structåç§°ç›¸åŒï¼Œå°±è¦å¼•ç”¨åˆ°çˆ¶çº§
                    // use std::collections::HashMap;
                    // let mut map = HashMap::new();
                    // map.insert(1, "v");
                    // println!("{:?}", map)
                // ä½¿ç”¨useå°†è·¯å¾„ï¼ˆåç§°ï¼‰å¯¼å…¥å¯¼ä½œç”¨åŸŸå†…åï¼Œè¯¥åç§°åœ¨æ­¤ä½œç”¨åŸŸå†…äº‹ç§æœ‰çš„
            // ä½¿ç”¨å¤–éƒ¨åŒ…ï¼ˆpackageï¼‰
                // Cargo.toml æ·»åŠ ä¾èµ–çš„åŒ…ï¼ˆpackageï¼‰ï¼Œé€šè¿‡https://crate.io/ä¸‹è½½åŒ…
                // ç”¨useå°†ç‰¹å®šæ¡ç›®å¼•å…¥ä½œç”¨åŸŸ
                    // use rand::Rng; 
                // ä½¿ç”¨åµŒå¥—è·¯å¾„æ¸…ç†å¤§é‡çš„useè¯­å¥
                    // å¦‚æœä½¿ç”¨åŒä¸€ä¸ªåŒ…æˆ–æ¨¡å—ä¸‹çš„å¤šä¸ªæ¡ç›®ï¼ˆä¾‹å­ï¼‰
                    // å¯ä½¿ç”¨åµŒå¥—è·¯å¾„åœ¨åŒä¸€è¡Œå†…å°†ä¸Šè¿°æ¡ç›®è¿›è¡Œå¼•å…¥
                        // è·¯å¾„ç›¸åŒçš„éƒ¨åˆ†::{è·¯å¾„å·®å¼‚çš„éƒ¨åˆ†}
                            // use std::{cmp::Ordering, io};  ==  use std::cmp::Ordering; use std::io;
                        // å¦‚æœä¸¤ä¸ªuseè·¯å¾„ä¹‹ä¸€æ˜¯å¦ä¸€ä¸ªçš„å­è·¯å¾„ï¼Œä½¿ç”¨self
                            // use std::io::{self,Write}  == use std::io; use std::io::Write;
                // é€šé…ç¬¦*
                    // å¯ä»¥ä½¿ç”¨*æŠŠè·¯å¾„ä¸­æ‰€æœ‰çš„å…¬å…±æ¡ç›®éƒ½å¼•å…¥åˆ°ä½œç”¨åŸŸï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
                        // use std::collections::*;
                    // æµ‹è¯•ï¼šå°†æ‰€æœ‰è¢«æµ‹è¯•çš„ä»£ç å¼•å…¥testsæ¨¡å—
                    // æœ‰æ—¶è¢«ç”¨äºé¢„å¯¼å…¥ï¼ˆpreludeï¼‰æ¨¡å—
            // å°†æ¨¡å—å†…å®¹ç§»åŠ¨åˆ°å…¶ä»–æ–‡ä»¶
                // æ¨¡å—å®šä¹‰æ—¶ï¼Œå¦‚æœæ¨¡å—ååè¾¹æ˜¯;ï¼Œ è€Œä¸æ˜¯ä»£ç å—ï¼ŒRustä¼šä»æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹ 
                // æ¨¡å—æ ‘çš„ç»“æ„ä¸ä¼šå‘ç”Ÿå˜åŒ–
                // éšç€æ¨¡å—é€æ¸å˜å¤§ï¼Œè¯¥æŠ€æœ¯è®©ä½ å¯ä»¥æŠŠæ¨¡å—çš„å†…å®¹ç§»åŠ¨åˆ°å…¶ä»–æ–‡ä»¶ä¸­
        /* å¸¸ç”¨çš„é›†åˆ,éƒ½æ˜¯å­˜æ”¾åœ¨heapä¸­çš„ï¼Œæ‰€ä»¥å¤§å°å¯ä»¥æ˜¯ä¸å›ºå®šçš„ */  
            // Vectorï¼Œ Vec<T>,ç”±æ ‡å‡†åº“æä¾›ï¼Œå¯å­˜å‚¨å¤šä¸ªå€¼ï¼Œåªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„æ•°æ®ï¼Œå€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾
                // let ve: Vec<i32> = Vec::new();
                // println!("{:?}", ve)
            // é€šå¸¸ä½¿ç”¨åˆå§‹å€¼åˆ›å»ºVec<T>ï¼Œä½¿ç”¨vec!å®
                // let ve1 = vec![1,2,3];
                // println!("{:?}", ve1)
            // ä¸ä»»ä½•å…¶ä»–structä¸€æ ·ï¼Œå½“Vectorç¦»å¼€ä½œç”¨åŸŸåï¼Œå®ƒåŒ…æ‹¬é‡Œé¢æ‰€æœ‰çš„å…ƒç´ éƒ½ä¼šè¢«æ¸…ç†æ‰
            // è·å–vectorå…ƒç´ æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æŒ‰ç…§ç´¢å¼•å–å€¼ï¼Œä¸€ç§ç”¨getæ–¹æ³•ï¼Œéœ€è¦æ³¨æ„ï¼Œå¦‚æœç”¨ç´¢å¼•ï¼Œä¸€æ—¦ç´¢å¼•è¶…å‡ºvecçš„ä½ç½®ï¼Œä¼šæŠ¥é”™ï¼Œgetåˆ™ä¼šè¿”å›None
                // let v_list = vec![4,5,6,1,9,10,2,3,7,8];
                // let night = &v_list[7];
                // println!("åˆ—è¡¨ç¬¬8ä½çš„æ•°å­—æ˜¯: {}", night);
                // println!("ç”¨getæ–¹æ³•å–ç¬¬ä¸‰ä½æ•°å­—: {:?}", v_list.get(2));
                // match v_list.get(100) {
                //     Some(third) => println!("ç”¨getæ–¹æ³•å–ç¬¬5ä½æ•°å­—:{}", third),
                //     None => println!("æ²¡æœ‰å–åˆ°å½“å‰ä¸‹æ ‡çš„å€¼"),
                // }
            // Vectorçš„æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™
                // ä¸èƒ½åœ¨åŒä¸€ä½œç”¨åŸŸå†…åŒæ—¶æ‹¥æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨
                    // let mut v_list1 = vec![1,2,3,4,5,6];
                    // let first = &v_list1[0];
                    // // v_list1.push(100);  // è¿™é‡Œå°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºåŒä¸€ä¸ªä½œç”¨åŸŸæœ‰ä¸€ä¸ªå¯å˜å’Œä¸€ä¸ªä¸å¯å˜
                    // println!("å½“å‰æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œå€¼ä¸º{}", first);  // è¿™é‡Œä½¿ç”¨äº†firstï¼Œæ‰€ä»¥æ‰å¯ä»¥ç»§ç»­ä½¿ç”¨å¯å˜å¼•ç”¨ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨ï¼Œå°±pushï¼Œåˆ™ä¼šæŠ¥é”™
                    // v_list1.push(80);
                    // println!("å½“å‰æ˜¯å¯å˜å¼•ç”¨ï¼šå€¼ä¸º{:?}", v_list1)
                // éå†Vectorçš„å€¼
                    // let v_list3 = vec![1,3,5,6,34,5,6,2,34344,53];
                    // for i in &v_list3 {
                    //     println!("{}", i);
                    // }

                    // let mut v_list3 = vec![1,3,5,6,34,5,6,2,34344,53];
                    // for i in &mut v_list3 {
                    //     // *i æ˜¯è§£å¼•ç”¨
                    //     *i *= 10;
                    // }
                    // println!("{:?}", v_list3)
            // ä½¿ç”¨enumåœ¨Vectorä¸­æ¥å­˜å‚¨å¤šç§æ•°æ®ç±»å‹
                // Enumçš„å˜ä½“å¯ä»¥é™„ä»¶ä¸åŒç±»å‹çš„æ•°æ®
                // Enumçš„å˜ä½“å®šä¹‰åœ¨åŒä¸€ä¸ªenumç±»å‹ä¸‹
                    // let row = vec![
                    //     SpreadsheetCell::Int(34),
                    //     SpreadsheetCell::Text(String::from("blue!")),
                    //     SpreadsheetCell::Float(34.23),
                    // ];
                    // println!("{:?}", row)
            // String ç±»å‹
                // Rustçš„æ ¸å¿ƒè¯­è¨€å±‚é¢ï¼Œåªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡strï¼ˆæˆ–&strï¼‰
                // å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼šå¯¹å­˜å‚¨åœ¨å…¶ä»–åœ°æ–¹ã€utf-8ç¼–ç çš„å­—ç¬¦ä¸²çš„å¼•ç”¨
                    //å­—ç¬¦ä¸²å­—é¢å€¼ï¼šå­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œä¹Ÿæ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡
                // Stringç±»å‹æ˜¯æ ‡å‡†åº“è€Œä¸æ˜¯æ ¸å¿ƒè¯­è¨€ 
                    // å¯å¢é•¿ï¼Œå¯ä¿®æ”¹ï¼Œå¯è·å¾—æ‰€æœ‰æƒï¼ŒUTF-8ç¼–ç 
                // é€šå¸¸è¯´çš„å­—ç¬¦ä¸²æ˜¯æŒ‡Stringå’Œ&strï¼Œå› ä¸ºåœ¨æ ‡å‡†åº“é‡Œç”¨çš„å¤šï¼ŒUTF-8ç¼–ç 
                // å…¶ä»–ç±»å‹å­—ç¬¦ä¸²
                    // Rustçš„æ ‡å‡†åº“è¿˜åŒ…å«äº†å¾ˆå¤šå…¶ä»–çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œä¾‹å¦‚OsStringã€OsStrã€CStringã€Cstr
                        // Stringåç¼€æ˜¯å¯ä¿®æ”¹çš„ï¼Œæ‹¥æœ‰æ‰€æœ‰æƒ
                        // stråç¼€æ˜¯å€Ÿç”¨æ‰€æœ‰æƒï¼Œæ˜¯ä¸å¯å˜çš„
                        // å¯å­˜å‚¨ä¸åŒç¼–ç çš„æ–‡æœ¬æˆ–åœ¨å†…å­˜ä¸­ä»¥ä¸åŒçš„å½¢å¼å±•ç°
                    // library crateé’ˆå¯¹å­˜å‚¨å­—ç¬¦ä¸²å¯æä¾›æ›´å¤šçš„é€‰é¡¹
                // ä½¿ç”¨åˆå§‹å€¼æ¥åˆ›å»ºString
                    // to_string()æ–¹æ³•ï¼Œå¯ç”¨äºå®ç°äº†Display traitçš„ç±»å‹ï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸²å­—é¢å€¼
                    // String::from()å‡½æ•°ï¼Œä»å­—é¢å€¼åˆ›å»ºStringä¾‹å­
                        // let data = "initial contents";
                        // let s = data.to_string();
                        // println!("{:?}", s);
                        // let ss = "init info".to_string();
                        // println!("{:?}", ss)
                // æ›´æ–°String
                    // push_str:æŠŠä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡é™„åŠ åˆ°String
                    // pushï¼šæŠŠå•ä¸ªå­—ç¬¦é™„åŠ åˆ°String
                    // + ï¼šå­—ç¬¦ä¸²æ‹¼æ¥,ä½¿ç”¨äº†ç±»ä¼¼è¿™ä¸ªç­¾åçš„æ–¹æ³• fn add(self, s: &str) -> String{...}
                    // format!å®ï¼šå¯ä»¥æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œå¹¶ä¸”ä¸ä¼šè·å–ä»»ä½•å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²
                        // let s1 = String::from("å°æ³¼çŒ´ï¼");
                        // let s2 = String::from("ä½ è¦å»çˆ¬æ ‘å—ï¼Ÿ");
                        // // let s3 = s1 + &s2;
                        // let s3 = String::from("åˆ«æ‰æ²Ÿé‡Œå»äº†ï¼");
                        // // let s4 = s1 + "-" + &s2 + "-" + &s3;
                        // let s4 = format!("{}-{}-{}", s1, s2, s3);
                        // println!("{}", s4)
                // StringæŒ‰å·¦å³è¿›è¡Œè®¿é—®
                    // Rustä¸æ”¯æŒStringæŒ‰ç…§ç´¢å¼•è¿›è¡Œè®¿é—®ï¼Œå› ä¸ºå†…éƒ¨å­˜æ”¾çš„æ˜¯u8,ä¹Ÿå°±æ˜¯å­—èŠ‚ç±»å‹çš„Byte
                    // Rustæœ‰ä¸‰ç§çœ‹å¾…å­—ç¬¦ä¸²çš„æ–¹å¼
                        // å­—èŠ‚ï¼ˆBytesï¼‰
                        // æ ‡é‡å€¼ï¼ˆScalar Valuesï¼‰
                        // å­—å½¢ç°‡ï¼ˆGrapheme Clustersï¼‰ï¼šæœ€æ¥è¿‘â€œå­—æ¯â€
                            // let s1 = "å°æ³¼çŒ´!";
                            // // for b in s1.bytes() { 
                            // //     println!("{}", b)
                            // // }
                            // for b in s1.chars() {
                            //     println!("{}", b)
                            // }
                //åˆ‡å‰²String
                    // å¯ä»¥ä½¿ç”¨[]å’Œä¸€ä¸ªèŒƒå›´æ¥åˆ›å»ºå­—ç¬¦ä¸²åˆ‡ç‰‡
                        // å¿…é¡»è°¨æ…ä½¿ç”¨
                        // å¦‚æœåˆ‡å‰²æ—¶è·¨è¶Šäº†å­—ç¬¦ä¾¿æ·ï¼Œç¨‹åºå°±ä¼španic
                            // (b1,b2),(b3,b4),(b5,b6),(b7,b8) å¦‚æœåˆ‡åˆ°äº†(b1,b2),(b3å°±ä¼šæŠ¥é”™
        /* HashMap */
            // HashMap<K,V>: é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨æ•°æ®ï¼Œä¸€ä¸ªé”®ï¼ˆkeyï¼‰å¯¹åº”ä¸€ä¸ªå€¼ï¼ˆValueï¼‰
            // Hashå‡½æ•°ï¼šå†³å®šå¦‚ä½•åœ¨å†…å­˜ä¸­å­˜æ”¾Kå’ŒV
            // é€‚ç”¨åœºæ™¯ï¼šé€šè¿‡Kï¼ˆä»»ä½•ç±»å‹ï¼‰æ¥å¯»æ‰¾æ•°æ®ï¼Œè€Œä¸æ˜¯é€šè¿‡ç´¢å¼•
                // use std::collections::HashMap;
                // // let mut scores = HashMap::new();
                // // scores.insert(String::from("Blue"), 3);
                // // scores.insert(4, 5);
                // let mut scores = HashMap::new();
                // scores.insert(String::from("Blue"), 3);
                // scores.insert(4.to_string(), 5);
                // println!("{:?}", scores);
            // ç”±äºHashMapç”¨çš„æ¯”è¾ƒå°‘ï¼Œä¸åœ¨é¢„å¯¼å…¥ï¼ˆPreludeï¼‰ä¸­
            // æ ‡å‡†åº“å¯¹å…¶æ”¯æŒçš„æ¯”è¾ƒå°‘ï¼Œæ²¡æœ‰å†…ç½®çš„å®æ¥åˆ›å»ºHashMap
            // æ•°æ®å­˜å‚¨åœ¨heapä¸Š
            // ä¸€ä¸ªHashMapä¸­æ‰€æœ‰çš„Kå¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹ï¼Œæ‰€æœ‰çš„Vå¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹
            // å¦ä¸€ç§åˆ›å»ºHashMapçš„æ–¹å¼ï¼šcollectæ–¹æ³•
                // åœ¨å…ƒç´ ç±»å‹ä¸ºTupleï¼ˆå…ƒç»„ï¼‰çš„Vectorä¸Šä½¿ç”¨collectæ–¹æ³•ï¼Œå¯ä»¥ç»„ä»¶ä¸€ä¸ªHashMap
                    // è¦æ±‚Tupleæœ‰ä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªä½œä¸ºKï¼Œå¦ä¸€ä¸ªä½œä¸ºV
                    // collectæ–¹æ³•å¯ä»¥æŠŠæ•°æ®æ•´åˆæˆå¾ˆå¤šç§é›†åˆç±»å‹ï¼ŒåŒ…æ‹¬HashMapï¼Œè¿”å›å€¼éœ€è¦æ˜¾ç¤ºæŒ‡æ˜ç±»å‹
                    // let teams = vec![String::from("Blue"), String::from("Yellow")];
                    // let initial_scores = vec![10, 50];
                    // let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
                    // println!("{:?}", scores);
            // HashMapçš„æ‰€æœ‰æƒ
                // å¯¹äºå®ç°äº†Copy traitçš„ç±»å‹ï¼ˆä¾‹å¦‚i32ï¼‰ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ°HashMapä¸­
                // å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼ˆä¾‹å¦‚Stringï¼‰ï¼Œå€¼ä¼šè¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒä¼šè½¬ç§»ç»™HashMap
                // å¦‚æœå°†å€¼çš„å¼•ç”¨æ’å…¥HashMapï¼Œå€¼æœ¬èº«ä¸ä¼šç§»åŠ¨
                    // åœ¨HashMapæœ‰æ•ˆæœŸé—´ï¼Œè¢«å¼•ç”¨çš„å€¼å¿…é¡»ä¿æŒæœ‰æ•ˆ
            // è®¿é—®HashMapä¸­çš„å€¼
                // getï¼šè¿”å›ä¸€ä¸ªOption<&V>
                    // let mut scores = HashMap::new();
                    // scores.insert(String::from("Blue"), 10);
                    // scores.insert(String::from("Yellow"), 50);
                    // // let team_name = String::from("Blue");
                    // // let score = scores.get(&team_name);
                    // // match score {
                    // //     Some(s) => println!("{:?}", s),
                    // //     None => println!("None"),
                    // // };
                    // //  éå†HashMap
                    // for (key, value) in &scores {
                    //     println!("{}:{}", key, value);
                    // }
            // æ›´æ–°HashMapä¸­çš„å€¼
                // HashMapå¤§å°å¯å˜
                // æ¯ä¸ªKeyåªèƒ½æœ‰ä¸€ä¸ªå€¼
                // æ›´æ–°HashMapä¸­çš„æ•°æ®
                    // Kå·²å­˜åœ¨ï¼Œå¯¹åº”ä¸€ä¸ªV
                        // æ›¿æ¢ç°æœ‰çš„V
                            // let mut scores = HashMap::new(); 
                            // scores.insert(String::from("Blue"), 10);
                            // scores.insert(String::from("Blue"), 25);
                            // println!("{:?}", scores);
                        // ä¿ç•™ç°æœ‰çš„Vï¼Œå¿½ç•¥æ–°çš„V
                        // åˆå¹¶ç°æœ‰çš„Vå’Œæ–°çš„V
                            // let text = "hello world wonderful world";
                            // let mut map = HashMap::new();
                            // // ä½¿ç”¨ split_whitespace() æ–¹æ³•æ‹†åˆ†å­—ç¬¦ä¸²ï¼Œå¹¶è¿­ä»£è¾“å‡ºæ¯ä¸ªå•è¯
                            // for word in text.split_whitespace() {
                            //     let count = map.entry(word).or_insert(0);
                            //     *count += 1;
                            // }
                            // println!("{:?}", map);  // {"world": 2, "hello": 1, "wonderful": 1}
                    // Kä¸å­˜åœ¨ï¼Œæ’å…¥æ–°Vï¼Œæ·»åŠ ä¸€å¯¹Kï¼ŒV,ä½¿ç”¨entryæ–¹æ³•,Entryçš„æ–¹æ³•or_insert,å¦‚æœkå­˜åœ¨ï¼Œè¿”å›èµŒèµ¢çš„vçš„ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œkä¸å­˜åœ¨ï¼Œæ’å…¥æ–°V
                        // let mut scores = HashMap::new();
                        // scores.insert(String::from("Blue"), 33);
                        // scores.entry(String::from("Blue")).or_insert(50);  
                        // scores.entry(String::from("Yellow")).or_insert(50);
                        // println!("{:?}", scores);  // {"Yellow": 50, "Blue": 33}
        /* é”™è¯¯å¤„ç† */
            // Rustçš„å¯é æ€§ï¼šé”™è¯¯å¤„ç†
                // å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼šåœ¨ç¼–è¯‘æ—¶æç¤ºé”™è¯¯ï¼Œå¹¶å¤„ç†
            // é”™è¯¯çš„åˆ†ç±»ï¼š
                // å¯æ¢å¤çš„ï¼Œä¾‹å¦‚æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå¯å†æ¬¡å°è¯•
                // ä¸å¯æ¢å¤çš„ï¼Œä¾‹å¦‚å†…å­˜æº¢å‡ºï¼Œç¨‹åºå´©æºƒ
            // Rustæ²¡æœ‰ç±»ä¼¼å¼‚å¸¸çš„æœºåˆ¶
                // 1. panic! ï¼šç¨‹åºä¼šæ‰“å°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œå±•å¼€ï¼ˆunwindï¼‰ã€æ¸…ç†è°ƒç”¨æ ˆï¼ˆstackï¼‰ï¼Œé€€å‡ºç¨‹åº
                // 2. Result<T, E> 
                // 3. Option<T>
            // ä¸ºåº”å¯¹panicï¼Œå±•å¼€æˆ–ä¸­æ­¢ï¼ˆabortï¼‰è°ƒç”¨æ ˆ
                // é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“panicå‘ç”Ÿ
                    // 1.ç¨‹åºå±•å¼€è°ƒç”¨æ ˆï¼ˆå·¥ä½œé‡å¤§ï¼‰ï¼š Rustæ²¿ç€è°ƒç”¨æ ˆå¾€å›èµ°ï¼Œæ¸…ç†æ¯ä¸ªé‡åˆ°çš„å‡½æ•°ä¸­çš„æ•°æ®
                    // 2.æˆ–ç«‹å³ä¸­æ­¢è°ƒç”¨æ ˆï¼šä¸è¿›è¡Œæ¸…ç†ï¼Œç›´æ¥åœæ­¢ç¨‹åºï¼Œå†…å­˜éœ€è¦Osï¼ˆæ“ä½œç³»ç»Ÿï¼‰ æ¸…ç†
                // æƒ³è®©äºŒè¿›åˆ¶æ–‡ä»¶æ›´å°ï¼ŒæŠŠè®¾ç½®ä»â€œå±•å¼€â€æ”¹ä¸ºâ€œä¸­æ­¢â€
                    // åœ¨Cargo.tomlä¸­æ·»åŠ ï¼š
                    // [profile.release]
                    // panic = 'abort'
            // Resultæšä¸¾
                // Result<T, E>æšä¸¾ç±»å‹ 
                    // Tï¼šæ“ä½œæˆåŠŸæƒ…å†µä¸‹ï¼ŒOKå˜ä½“é‡Œè¿”å›æ•°æ®çš„ç±»å‹
                    // Eï¼šæ“ä½œå¤±è´¥æƒ…å†µä¸‹ï¼ŒErrå˜ä½“é‡Œè¿”å›é”™è¯¯çš„ç±»å‹
                // å¤„ç†Resultçš„ä¸€ç§æ–¹å¼ï¼šmatchè¡¨è¾¾å¼
                    // use std::fs::File;
                    // let f = File::open("hello.txt");
                    // // println!("{:?}", f)
                    // let f1 = match f {
                    //     Ok(file) => file,
                    //     Err(error) => panic!("Problem opening the file: {:?}", error),
                    // };
                    // println!("{:?}", f1)
                // å¯¹äºå¤šä¸ªmatchï¼Œè¿˜æœ‰ä¸€ç§æ–¹å¼ï¼šé—­åŒ…ï¼ˆclosureï¼‰Result<T, E>æœ‰å¾ˆå¤šæ–¹æ³•
                    // æ¥æ”¶é—­åŒ…ä½œä¸ºå‚æ•°ï¼Œæ˜¯matchå®ç°ï¼Œä½¿ç”¨è¿™äº›æ–¹æ³•è®©ä»£ç æ›´ç®€æ´
                        // use std::io::ErrorKind;
                        // let f = File::open("hello.txt").unwrap_or_else(|error| {
                        //     if error.kind() == ErrorKind::NotFound {
                        //         File::create("hello.txt").unwrap_or_else(|error| {
                        //             panic!("Problem creating the file: {:?}", error);
                        //         })
                        //     } else {
                        //         panic!("Problem opening the file: {:?}", error);
                        //     }
                        // });
                        // println!("{:?}", f);
                // unwrap()å’Œexpect()æ–¹æ³•
                    // unwrap()ï¼šå¦‚æœResultæ˜¯Okï¼Œè¿”å›Oké‡Œçš„å€¼ï¼Œå¦‚æœResultæ˜¯Errï¼Œè°ƒç”¨panic!
                        // let f = File::open("hello.txt").unwrap();
                    // expect()ï¼šå¦‚æœResultæ˜¯Okï¼Œè¿”å›Oké‡Œçš„å€¼ï¼Œå¦‚æœResultæ˜¯Errï¼Œè°ƒç”¨panic!ï¼Œå¹¶æ‰“å°è‡ªå®šä¹‰çš„é”™è¯¯ä¿¡æ¯
                        // let f = File::open("hello.txt").expect("æ‰“å¼€æ–‡ä»¶å¤±è´¥ hello.txt");
                        // println!("{:?}", f);
                // ä¼ æ’­é”™è¯¯ï¼šåœ¨å‡½æ•°å¤„å¤„ç†é”™è¯¯ï¼Œå°†é”™è¯¯è¿”å›ç»™è°ƒç”¨è€…
                    // let result = read_usernam_from_file();
                    // println!("{:?}", result)
                // ï¼Ÿè¿ç®—ç¬¦
                    // å¦‚æœResultæ˜¯Okï¼Œè¿”å›Oké‡Œçš„å€¼ï¼Œç„¶åç»§ç»­æ‰§è¡Œç¨‹åº
                    // å¦‚æœResultæ˜¯Errï¼ŒErræ˜¯æ•´ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œå°±åƒä½¿ç”¨äº†return
                        // let result = read_usernam_from_file();
                        // println!("{:?}", result)
                // ï¼Ÿä¸ from å‡½æ•°
                    // Trait std::convert::From ä¸Šçš„ from å‡½æ•°ï¼š
                // ç”¨äºé”™è¯¯ä¹‹é—´çš„è½¬æ¢
                    // è¢«ï¼Ÿæ‰€åº”ç”¨çš„é”™è¯¯ï¼Œä¼šéšå¼çš„è¢« from å‡½æ•°å¤„ç†
                // å½“ï¼Ÿè°ƒç”¨ from å‡½æ•°æ—¶ï¼š
                    // å®ƒæ‰€æ¥æ”¶çš„é”™è¯¯ç±»å‹ä¼šè¢«è½¬åŒ–ä¸ºå½“å‰å‡½æ•°è¿”å›ç±»å‹æ‰€å®šä¹‰çš„é”™è¯¯ç±»å‹ï¼ç”¨äºï¼šé’ˆå¯¹ä¸åŒé”™è¯¯åŸå› ï¼Œè¿”å›åŒä¸€ç§é”™è¯¯ç±»å‹
                    // åªè¦æ¯ä¸ªé”™è¯¯ç±»å‹å®ç°äº†è½¬æ¢ä¸ºæ‰€è¿”å›çš„é”™è¯¯ç±»å‹çš„ from å‡½æ•°
                // ?è¿ç®—ç¬¦ä¸mainå‡½æ•°
                    // mainå‡½æ•°è¿”å›ç±»å‹æ˜¯:()
                    // mianå‡½æ•°è¿”å›ç±»å‹ä¹Ÿå¯ä»¥æ˜¯:Result<T, E>
                    // Box<dyn Error>æ˜¯traitå¯¹è±¡ï¼šç®€å•ç†è§£â€œä»»ä½•å¯èƒ½çš„é”™è¯¯å¯¹è±¡â€
                        // fn main() -> Result<(), Box<dyn Error>> {
                        //     let f = File::open("hello.txt")?;
                        //     Ok(())
                        // }
            // ä»€ä¹ˆæ—¶å€™ç”¨panic
                // åœ¨å®šä¹‰ä¸€ä¸ªå¯èƒ½å¤±è´¥çš„å‡½æ•°æ—¶ï¼Œä¼˜å…ˆè€ƒè™‘è¿”å›Resultï¼Œå¦åˆ™å°±panic
            // é”™è¯¯å¤„ç†çš„æŒ‡å¯¼æ€§å»ºè®®
                // å½“ä»£ç æœ€ç»ˆå¯èƒ½å¤„äºæŸåçŠ¶æ€æ—¶ï¼Œæœ€å¥½ä½¿ç”¨ panic!
                    // æŸåçŠ¶æ€ï¼ˆ Bad state )ï¼šæŸäº›å‡è®¾ã€ä¿è¯ã€çº¦å®šæˆ–ä¸å¯å˜æ€§è¢«æ‰“ç ´
                    // ä¾‹å¦‚éæ³•çš„å€¼ã€çŸ›ç›¾çš„å€¼æˆ–ç©ºç¼ºçš„å€¼è¢«ä¼ å…¥ä»£ç 
                // ä»¥åŠä¸‹åˆ—ä¸­çš„ä¸€æ¡ï¼š
                    // è¿™ç§æŸåçŠ¶æ€å¹¶ä¸æ˜¯é¢„æœŸèƒ½å¤Ÿå¶å°”å‘ç”Ÿçš„äº‹æƒ…ã€‚
                    // åœ¨æ­¤ä¹‹åï¼Œæ‚¨çš„ä»£ç å¦‚æœå¤„äºè¿™ç§æŸåçŠ¶æ€å°±æ— æ³•è¿è¡Œã€‚
                    // åœ¨æ‚¨ä½¿ç”¨çš„ç±»å‹ä¸­æ²¡æœ‰ä¸€ä¸ªå¥½çš„æ–¹æ³•æ¥å°†è¿™äº›ä¿¡æ¯ï¼ˆå¤„äºæŸåçŠ¶æ€ï¼‰è¿›è¡Œç¼–ç 
            // åœºæ™¯å»ºè®®
                // è°ƒç”¨ä½ çš„ä»£ç ï¼Œä¼ å…¥æ— æ„ä¹‰çš„å‚æ•°å€¼ï¼š panic!
                // è°ƒç”¨å¤–éƒ¨ä¸å¯æ§ä»£ç ï¼Œè¿”å›éæ³•çŠ¶æ€ï¼Œä½ æ— æ³•ä¿®å¤ï¼š panic! å¦‚æœå¤±è´¥æ˜¯å¯é¢„æœŸçš„ï¼š Result 
                // å½“ä½ çš„ä»£ç å¯¹å€¼è¿›è¡Œæ“ä½œï¼Œé¦–å…ˆåº”è¯¥éªŒè¯è¿™äº›å€¼ï¼š panic!
            // ä¸ºéªŒè¯åˆ›å»ºè‡ªå®šä¹‰ç±»å‹
                // åˆ›å»ºæ–°çš„ç±»å‹ï¼ŒæŠŠéªŒè¯é€»è¾‘æ”¾åœ¨æ„é€ å®ä¾‹å‡½æ•°é‡Œ
                    // loop {
                    //     let guess = "321";
                    //     // è¿™é‡Œåªæ˜¯æ ¡éªŒçš„æ˜¯å¦æ˜¯æ•°å­—æ ¼å¼çš„å­—ç¬¦ä¸²
                    //     let guess_num: i32= match guess.trim().parse() {
                    //         Ok(num) => num,
                    //         Err(_) => continue,
                    //     };
                    //     // è¿™é‡Œé™åˆ¶çš„æ˜¯æ•°å­—æ˜¯å¦åœ¨1~100ä¹‹é—´
                    //     let guess_struct = Guess::new(guess_num);
                    //     println!("ä½ è¾“å…¥çš„æ•°å­—æ˜¯ {}", guess_struct.value());
                    // }
        /* ä»£ç å¤ç”¨ï¼Œæ³›å‹ï¼ŒTraitï¼Œç”Ÿå‘½å‘¨æœŸ */
            // ä»£ç å¤ç”¨
                // let num_list = vec![314,56,33,44,5,122,3443];
                // let largest = largest_fn(&num_list);
                // println!("largest: {}", largest)
            // æ³›å‹
                // æé«˜ä»£ç å¤ç”¨èƒ½åŠ›ï¼Œå¤„ç†é‡å¤ä»£ç çš„é—®é¢˜
                // æ³›å‹æ˜¯å…·ä½“ç±»å‹æˆ–å…¶ä»–å±æ€§çš„æŠ½è±¡ä»£æ›¿ï¼Œç¼–å†™çš„ä»£ç ä¸æ˜¯æœ€ç»ˆçš„ä»£ç ï¼Œè€Œæ˜¯ä¸€ç§æ¨¡æ¿ï¼Œé‡Œé¢æœ‰ä¸€äº›â€œå ä½ç¬¦â€ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶å°†â€œå ä½ç¬¦â€æ›¿æ¢ä¸ºå…·ä½“çš„ç±»å‹
                    // pub fn largest<T>(list: &[T]) -> T {...}
                // åœ¨structå®šä¹‰æ³›å‹
                    // let integer = Point { x: 5, y: 10 };
                    // let float = Point { x: 5.0, y: 10.0 };
                    // println!("integer: {:?}, float: {:?}", integer, float)
                // å¯ä»¥åªç”¨å¤šä¸ªæ³›å‹çš„ç±»å‹å‚æ•°ï¼Œä½†æ˜¯å¤ªå¤šçš„ç±»å‹å‚æ•°ï¼Œä»£ç å°±éœ€è¦å……è¶³ä¸ºå¤šä¸ªæ›´å°çš„å•å…ƒ
                // åœ¨Enumå®šä¹‰æ³›å‹
                        // enum Option<T> {
                        //     Some(T),
                        //     None,
                        // }
                        // enum Result<T, E> {
                        //     Ok(T),
                        //     Err(E),
                        // }
                // structé‡Œçš„æ³›å‹ç±»å‹å‚æ•°å¯ä»¥å’Œæ–¹æ³•çš„æ³›å‹ç±»å‹å‚æ•°ä¸åŒ
                    // let p1 = Point { x: 5, y: 10.4 };
                    // let p2 = Point {x: "hello", y:"connect"};
                    // let p3 = p1.mixup(p2);
                    // println!("p3: {:?}", p3);
            // Traitï¼ˆç‰¹æ€§ï¼Œç‰¹å¾ï¼‰
                //  æŸç§ç±»å‹å…·æœ‰å“ªäº›å¹¶ä¸”å¯ä»¥ä¸å…¶ä»–ç±»å‹å…±äº«çš„åŠŸèƒ½ï¼Œä¸€ä¸ªæŠ½è±¡çš„å®šä¹‰å…±äº«è¡Œä¸º
                // Trait bounds(çº¦æŸ)ï¼šæ³›å‹ç±»å‹å‚æ•°æŒ‡å®šä¸ºå®ç°äº†ç‰¹å¾çš„ç±»å‹
                // Traitä¸å…¶ä»–è¯­è¨€çš„æ¥å£(interface)ç±»ä¼¼ï¼Œä½†æ˜¯æœ‰äº›åŒºåˆ«
                // å®šä¹‰ä¸€ä¸ª Trait 
                    // Trait çš„å®šä¹‰ï¼šæŠŠæ–¹æ³•ç­¾åæ”¾åœ¨ä¸€èµ·ï¼Œæ¥å®šä¹‰å®ç°æŸç§ç›®çš„æ‰€å¿…éœ€çš„ä¸€ç»„è¡Œä¸ºã€‚
                    // å…³é”®å­—ï¼š trait 
                    // åªæœ‰æ–¹æ³•ç­¾åï¼Œæ²¡æœ‰å…·ä½“å®ç°
                    // trait å¯ä»¥æœ‰å¤šä¸ªæ–¹æ³•ï¼šæ¯ä¸ªæ–¹æ³•ç­¾åå ä¸€è¡Œï¼Œä»¥ï¼›ç»“å°¾-å®ç°è¯¥ trait çš„ç±»å‹å¿…é¡»æä¾›å…·ä½“çš„æ–¹æ³•å®ç°
                // åœ¨ç±»å‹ä¸Šå®ç°Trait
                    // ç›¸åŒç‚¹ï¼šä¸ä¸ºç±»å‹å®ç°æ–¹æ³•ç±»ä¼¼
                    // ä¸åŒç‚¹ï¼šimpl Xxxx for Tweet {...}, åœ¨implçš„å—é‡Œï¼Œéœ€è¦å¯¹Traité‡Œçš„æ–¹æ³•ç­¾åè¿›è¡Œå®ç°
                        // use rut::Tweet;
                        // use rut::Summary;
                        // let tweet = Tweet {
                        //     username: String::from("å°æ³¼çŒ´"),
                        //     content: String::from("å°æ³¼çŒ´çš„å°ç§˜å¯†"),
                        //     reply: false,
                        //     retweet: false,
                        // };
                        // println!("æ¨ç‰¹ä¿¡æ¯: {}", tweet.summarize());
                // å®ç° trait çš„çº¦æŸ
                    // å¯ä»¥åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª trait çš„å‰ææ¡ä»¶æ˜¯ï¼š
                        // è¿™ä¸ªç±»å‹æˆ–è¿™ä¸ª trait æ˜¯åœ¨æœ¬åœ° crate é‡Œå®šä¹‰çš„
                    // æ— æ³•ä¸ºå¤–éƒ¨ç±»å‹æ¥å®ç°å¤–éƒ¨çš„ trait :
                        // è¿™ä¸ªé™åˆ¶æ˜¯ç¨‹åºå±æ€§çš„ä¸€éƒ¨åˆ†ï¼ˆä¹Ÿå°±æ˜¯ä¸€è‡´æ€§ï¼‰ã€‚
                        // æ›´å…·ä½“åœ°è¯´æ˜¯å­¤å„¿è§„åˆ™ï¼šä¹‹æ‰€ä»¥è¿™æ ·å‘½åæ˜¯å› ä¸ºçˆ¶ç±»å‹ä¸å­˜åœ¨ã€‚
                        // æ­¤è§„åˆ™ç¡®ä¿å…¶ä»–äººçš„ä»£ç ä¸èƒ½ç ´åæ‚¨çš„ä»£ç ï¼Œåä¹‹äº¦ç„¶ã€‚
                        // å¦‚æœæ²¡æœ‰è¿™ä¸ªè§„åˆ™ï¼Œä¸¤ä¸ª crate å¯ä»¥ä¸ºåŒä¸€ç±»å‹å®ç°åŒä¸€ä¸ª trait , Rust å°±ä¸çŸ¥é“åº”è¯¥ä½¿ç”¨å“ªä¸ªå®ç°äº†ã€‚
                // Trait ä½œä¸ºå‚æ•°
                    // impl Trait è¯­æ³•ï¼Œé€‚ç”¨äºç®€å•æƒ…å†µ
                    // Trait boundè¯­æ³•ï¼šé€‚ç”¨äºå¤æ‚æƒ…å†µï¼Œimpl Traitè¯­æ³•æ˜¯Trait boundçš„è¯­æ³•ç³–
                    // ä½¿ç”¨ + æŒ‡å®šå¤šä¸ªTrait bound
                // å®ç°Traitä½œä¸ºè¿”å›ç±»å‹
                    // impl Traitè¯­æ³•ï¼Œåªèƒ½è¿”å›ç¡®å®šçš„åŒä¸€ç±»å‹ï¼Œå¦‚æœè¿”å›å¯èƒ½ä¸åŒç±»å‹ï¼Œå³ä¾¿è¿™ä¸ªç±»å‹å®ç°äº†è¿™ä¸ªTraitï¼Œä¹Ÿä¼šæŠ¥é”™
                // ä½¿ç”¨ Trait Bound æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•
                    // åœ¨ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°çš„ impl å—ä¸Šä½¿ç”¨ Trait bound ï¼Œæˆ‘ä»¬å¯ä»¥æœ‰æ¡ä»¶çš„ä¸ºå®ç°äº†ç‰¹å®š Trait çš„ç±»å‹æ¥å®ç°æ–¹æ³•
                    // ä¹Ÿå¯ä»¥ä¸ºå®ç°äº†å…¶å®ƒ Trait çš„ä»»æ„ç±»å‹æœ‰æ¡ä»¶çš„å®ç°æŸä¸ª Trait
            // ç”Ÿå‘½å‘¨æœŸ
                // Rustçš„æ¯ä¸ªå¼•ç”¨éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸ
                // å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯éšå¼çš„ï¼Œå¯è¢«æ¨æ–­çš„
                // å½“å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½ä»¥ä¸åŒçš„æ–¹å¼äº’ç›¸å…³è”æ—¶ï¼Œæ‰‹åŠ¨æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°
                    // let r;
                    // {
                    //     let x = 5;
                    //     r = &x;
                    // }
                    // println!("r: {}", r);
                // ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
                    // let s1 = String::from("hello");
                    // let s2 = "å°æ³¼çŒ´ ";
                    // let res = longest(s1.as_str(), s2);
                    // print!("{}", res)
                    // let novel = String::from("Call me Ishmael. Some years ago... We ? and I met a traveller from an island far far away.");
                    // let first_sentence = novel.split('.').next().expect("Could not find a '.'");
                    // let ii = ImportantExcerpt {
                    //     part: first_sentence,
                    //     excerpt: novel.split('?').next().expect("Could not find a '.'"),
                    // };
                    // println!("{:?}", ii.part);
                    // println!("{:?}", ii.excerpt)
                // ç”Ÿå‘½å‘¨æœŸçš„çœç•¥
                    // æ¯ä¸ªå¼•ç”¨éƒ½æœ‰ç”Ÿå‘½å‘¨æœŸï¼Œéœ€è¦ä¸ºä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°æˆ–structæŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°
                // ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
                    // åœ¨ Rust å¼•ç”¨åˆ†æä¸­æ‰€ç¼–å…¥çš„æ¨¡å¼ç§°ä¸ºç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚ï¹£è¿™äº›è§„åˆ™æ— éœ€å¼€å‘è€…æ¥éµå®ˆ
                    // å®ƒä»¬æ˜¯ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œç”±ç¼–è¯‘å™¨æ¥è€ƒè™‘
                    // å¦‚æœä½ çš„ä»£ç ç¬¦åˆè¿™äº›æƒ…å†µï¼Œé‚£ä¹ˆå°±æ— éœ€æ˜¾å¼æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
                // ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ä¸ä¼šæä¾›å®Œæ•´çš„æ¨æ–­ï¼š
                    // å¦‚æœåº”ç”¨è§„åˆ™åï¼Œå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä»ç„¶æ¨¡ç³Šä¸æ¸…â†’ç¼–è¯‘é”™è¯¯ï¹£è§£å†³åŠæ³•ï¼šæ·»åŠ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè¡¨æ˜å¼•ç”¨é—´çš„ç›¸äº’å…³ç³»
                // ç”Ÿå‘½å‘¨æœŸçœç•¥çš„ä¸‰ä¸ªè§„åˆ™
                    // ç¼–è¯‘å™¨ä½¿ç”¨3ä¸ªè§„åˆ™åœ¨æ²¡æœ‰æ˜¾å¼æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µä¸‹ï¼Œæ¥ç¡®å®šå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ-
                        // è§„åˆ™1åº”ç”¨äºè¾“å…¥ç”Ÿå‘½å‘¨æœŸ
                        // è§„åˆ™2ã€3åº”ç”¨äºè¾“å‡ºç”Ÿå‘½å‘¨æœŸ
                        // å¦‚æœç¼–è¯‘å™¨åº”ç”¨å®Œ3ä¸ªè§„åˆ™ä¹‹åï¼Œä»ç„¶æœ‰æ— æ³•ç¡®å®šç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨â†’æŠ¥é”™
                        // è¿™äº›è§„åˆ™é€‚ç”¨äº fn å®šä¹‰å’Œ impl å—
                    // è§„åˆ™1ï¼šæ¯ä¸ªå¼•ç”¨ç±»å‹çš„å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
                    // è§„åˆ™2ï¼šå¦‚æœåªæœ‰1ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
                    // è§„åˆ™3ï¼šå¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ï¼†self æˆ–ï¼†mut self ï¼ˆæ˜¯æ–¹æ³•ï¼‰ï¼Œé‚£ä¹ˆ self çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
                // æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
                    // åœ¨ struct ä¸Šä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå®ç°æ–¹æ³•ï¼Œè¯­æ³•å’Œæ³›å‹å‚æ•°çš„è¯­æ³•ä¸€æ ·
                    // åœ¨å“ªå£°æ˜å’Œä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä¾èµ–äºï¼š
                        // ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¯å¦å’Œå­—æ®µã€æ–¹æ³•çš„å‚æ•°æˆ–è¿”å›å€¼æœ‰å…³
                    // struct å­—æ®µçš„ç”Ÿå‘½å‘¨æœŸåï¼š
                        // åœ¨ impl åå£°æ˜
                        // åœ¨ struct ååä½¿ç”¨
                        // è¿™äº›ç”Ÿå‘½å‘¨æœŸæ˜¯ struct ç±»å‹çš„ä¸€éƒ¨åˆ†
                    // impl å—å†…çš„æ–¹æ³•ç­¾åä¸­ï¼š
                        // å¼•ç”¨å¿…é¡»ç»‘å®šäº struct å­—æ®µå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œæˆ–è€…å¼•ç”¨æ˜¯ç‹¬ç«‹çš„ä¹Ÿå¯ä»¥
                        // ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ç»å¸¸ä½¿å¾—æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ˜¯å¿…é¡»çš„
                // é™æ€ç”Ÿå‘½å‘¨æœŸ
                    // 'static æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸï¼šæ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´
                        // ä¾‹å¦‚ï¼šæ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢å€¼éƒ½æ‹¥æœ‰'static ç”Ÿå‘½å‘¨æœŸ
                            // let s :&'static str =" I have a static lifetime .";
                    // ä¸ºå¼•ç”¨æŒ‡å®š'static ç”Ÿå‘½å‘¨æœŸå‰è¦ä¸‰æ€ï¼š
                        // æ˜¯å¦éœ€è¦å¼•ç”¨åœ¨ç¨‹åºæ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…éƒ½å­˜æ´»
        /* æ–­è¨€ Assert */
            // assertï¼å®ï¼Œæ¥è‡ªæ ‡å‡†åº“ï¼Œç”¨æ¥ç¡®å®šæŸä¸ªçŠ¶æ€æ˜¯å¦ä¸ºtrue
                // true -> æ–­è¨€æˆåŠŸï¼Œfalse -> æ–­è¨€å¤±è´¥ï¼Œç¨‹åºpanic
                // assert! å®ä¸ä¼šè¿”å›æ–­è¨€çš„ç»“æœï¼Œè€Œæ˜¯åœ¨æ–­è¨€å¤±è´¥æ—¶è§¦å‘ panic
                // larger_can_hold_smaller()
            // ä½¿ç”¨ assert_eq! å® å’Œ assert_ne! å®æµ‹è¯•ç›¸ç­‰æ€§
                // éƒ½æ¥è‡ªæ ‡å‡†åº“ï¼Œåˆ¤æ–­ä¸¤ä¸ªå‚æ•°æ˜¯å¦ç›¸ç­‰æˆ–ä¸ç­‰ï¼Œå®é™…ä¸Šï¼Œä»–ä»¬ä½¿ç”¨çš„æ˜¯== å’Œ != è¿ç®—ç¬¦
                // æ–­è¨€å¤±è´¥ä¼šè‡ªåŠ¨æ‰“å°å‡ºä¸¤ä¸ªå‚æ•°çš„å€¼
                    // it_add_two()
            // æ·»åŠ è‡ªå®šä¹‰çš„é”™è¯¯ä¿¡æ¯
                // assert_eq! å®å’Œ assert_ne! å®éƒ½æ¥å—ä¸€ä¸ªé¢å¤–çš„å‚æ•°ï¼Œç”¨æ¥æä¾›é”™è¯¯ä¿¡æ¯ï¼Œå‰ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯å¿…å¡«çš„ï¼Œè‡ªå®šä¹‰æ¶ˆæ¯ä½œä¸ºç¬¬ä¸‰ä¸ªå‚æ•°
                // assert!ï¼šç¬¬ä¸€ä¸ªå‚æ•°å¿…å¡«ï¼Œè‡ªå®šä¹‰æ¶ˆæ¯ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°
                // è‡ªå®šä¹‰æ¶ˆæ¯å‚æ•°ä¼šè¢«ä¼ é€’ç»™format! å®ï¼Œç”¨æ¥æ ¼å¼åŒ–é”™è¯¯ä¿¡æ¯
                // greetings_contain_name()
        /* å‘½ä»¤è¡Œé¡¹ç›®ç¼–å†™ */
            // 12.1 æ¥æ”¶å‘½ä»¤è¡Œå‚æ•°
            // 12.2 è¯»å–æ–‡ä»¶
            // 12.3 é‡æ„ï¼šæ”¹è¿›æ¨¡å—å’Œé”™è¯¯å¤„ç†
            // 12.4 ä½¿ç”¨TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰å¼€å‘åº“åŠŸèƒ½
            // 12.5 ä½¿ç”¨ç¯å¢ƒå˜é‡
            // 12.6 å°†é”™è¯¯ä¿¡æ¯å†™å…¥æ ‡å‡†é”™è¯¯ï¼Œè€Œä¸æ˜¯æ ‡å‡†è¾“å‡º
            // é¡¹ç›®åœ¨/Users/bariuta/RustProjects/minigrepä¸­
        /* è¿­ä»£å™¨ï¼ˆiteratorsï¼‰å’Œé—­åŒ…ï¼ˆclosuresï¼‰*/
            // é—­åŒ…ï¼šå¯ä»¥æ•è·å…¶æ‰€åœ¨ç¯å¢ƒçš„åŒ¿åå‡½æ•°
                // é—­åŒ…ï¼šåŒ¿åå‡½æ•°ï¼Œ ä¿å­˜ä¸ºå˜é‡ï¼Œä½œä¸ºå‚æ•°ï¼Œå¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹åˆ›å»ºé—­åŒ…ï¼Œç„¶ååœ¨å¦ä¸€ä¸ªä¸Šä¸‹æ–‡ä¸­è°ƒç”¨é—­åŒ…æ¥å®Œæˆè¿ç®—ï¼Œå¯ä»å…¶å®šä¹‰çš„ä½œç”¨åŸŸæ•è·å€¼
                // é—­åŒ…çš„ç±»å‹æ¨æ–­
                    // é—­åŒ…ä¸è¦æ±‚æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹
                    // æŠŠé—­åŒ…é€šå¸¸å¾ˆçŸ­ï¼Œåªåœ¨ç‹­å°çš„ä¸Šä¸‹æ–‡ä¸­å·¥ä½œï¼Œç¼–è¯‘å™¨é€šå¸¸èƒ½æ¨æ–­å‡ºç±»å‹
                    // æ³¨æ„ï¼Œé—­åŒ…çš„å®šä¹‰æœ€ç»ˆåªä¼šä¸ºå‚æ•°ã€è¿”å›å€¼æ¨æ–­å‡ºå”¯ä¸€å…·ä½“çš„ç±»å‹
                        // let example_closure = |x| x;
                        // let s = example_closure(String::from("hello"));
                        // let n = example_closure(5);  // è¿™é‡Œå°±ä¼šæŠ¥é”™ï¼Œé—­åŒ…çš„ç±»å‹å·²ç»è¢«æ¨æ–­å‡ºæ¥äº†ï¼Œæ‰€ä»¥ä¸èƒ½å†æ›´æ”¹äº†
                // å¯¹äºä¼šé‡å¤è°ƒç”¨é—­åŒ…çš„ä»£ç 
                    // 1. å°†é—­åŒ…è°ƒç”¨ç»“æœå­˜å‚¨åœ¨å˜é‡ä¸­
                    // 2. åˆ›å»ºä¸€ä¸ªstructæ¥ä¿å­˜é—­åŒ…å’Œæ‰§è¡Œç»“æœï¼Œè¿™ä¸ªæ¨¡å¼é€šå¸¸å«åšè®°å¿†åŒ–ï¼ˆmemoizationï¼‰æˆ–å»¶è¿Ÿè®¡ç®—ï¼ˆlazy evaluationï¼‰
                        // structçš„å®šä¹‰éœ€è¦çŸ¥é“æ‰€æœ‰å­—æ®µçš„ç±»å‹ï¼Œéœ€è¦æŒ‡æ˜é—­åŒ…çš„ç±»å‹
                        // æ¯ä¸ªé—­åŒ…å®ä¾‹éƒ½æœ‰è‡ªå·±å”¯ä¸€çš„åŒ¿åç±»å‹ï¼ŒåŠæ—¶ä¸¤ä¸ªé—­åŒ…ç­¾åå®Œå…¨ä¸€æ ·
                        // æ‰€ä»¥éœ€è¦ä½¿ç”¨æ³›å‹å’Œ Trait Bound æ¥æŒ‡å®šé—­åŒ…ç±»å‹
                        // æ‰€æœ‰é—­åŒ…éƒ½è‡³å°‘å®ç°äº†å·²ä¸‹traitä¹‹ä¸€ï¼š
                            // FnOnceï¼šé—­åŒ…å¯ä»¥è°ƒç”¨ä¸€æ¬¡
                            // FnMutï¼šé—­åŒ…å¯ä»¥ä¿®æ”¹æ•è·çš„å¤–éƒ¨å˜é‡
                            // Fnï¼šé—­åŒ…å¯ä»¥ä¸ä¿®æ”¹æ•è·çš„å¤–éƒ¨å˜é‡
                            // generate_workout(10, 3)
                        // ä½¿ç”¨ç¼“å­˜å™¨ï¼ˆCacherï¼‰å®ç°çš„é™åˆ¶
                // é—­åŒ…å¯ä»¥æ•è·ç¯å¢ƒ
                    // é—­åŒ…å¯ä»¥æ•è·ç¯å¢ƒï¼Œå³é—­åŒ…å¯ä»¥è®¿é—®å…¶å®šä¹‰çš„ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œä½†æ˜¯ä¼šäº§ç”Ÿå¼€é”€
                    // æ•è·æ–¹å¼
                        // FnOnceï¼šé—­åŒ…å¯ä»¥è°ƒç”¨ä¸€æ¬¡ï¼Œè·å¾—æ‰€æœ‰æƒ
                        // FnMutï¼šé—­åŒ…å¯ä»¥ä¿®æ”¹æ•è·çš„å¤–éƒ¨å˜é‡ï¼Œ å¯å˜å€Ÿç”¨
                        // Fnï¼šé—­åŒ…å¯ä»¥ä¸ä¿®æ”¹æ•è·çš„å¤–éƒ¨å˜é‡ï¼Œ ä¸å¯å˜å€Ÿç”¨
                    // åˆ›å»ºé—­åŒ…æ—¶ï¼Œé€šè¿‡é—­åŒ…å¯¹ç¯å¢ƒå€¼çš„ä½¿ç”¨ï¼Œ Rust æ¨æ–­å‡ºå…·ä½“ä½¿ç”¨å“ªä¸ª trait :
                        // æ‰€æœ‰çš„é—­åŒ…éƒ½å®ç°äº† FnOnce 
                        // æ²¡æœ‰ç§»åŠ¨æ•è·å˜é‡çš„å®ç°äº† FnMut 
                        // æ— éœ€å¯å˜è®¿é—®æ•è·å˜é‡çš„é—­åŒ…å®ç°äº† Fn
                // moveå…³é”®å­—
                    // åœ¨å‚æ•°åˆ—è¡¨ä½¿ç”¨moveå…³é”®å­—ï¼Œå¯ä»¥å¼ºåˆ¶é—­åŒ…å–å¾—å®ƒæ‰€ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒ
                    // ä½¿ç”¨åœºæ™¯ï¼šæ¡£è¡¨ä¼ é€’ç»™æ–°çº¿ç¨‹ä»¥ç§»åŠ¨æ•°æ®ä½¿å…¶å½’æ–°çº¿ç¨‹æ‰€æœ‰æ—¶ï¼Œæ­¤æŠ€æœ¯æœ€ä¸ºæœ‰ç”¨
                        // let y = vec![1, 2, 3];
                        // let equal_to_y = move |z: Vec<i32>| z == y;
                        // println!("equal_to_x = {:?}", y);  // æŠ¥é”™ value borrowed here after move
            // è¿­ä»£å™¨
                    // let v1 = vec![1, 2, 3];
                    // let v1_iter = v1.iter();
                    // for i in v1_iter {
                    //     println!("{:?}", i);
                    // }
                // Iterator trait ä»…ä»…è¦æ±‚å®ç°ä¸€ä¸ªæ–¹æ³•ï¼šnext 
                    // æ¯æ¬¡è¿”å›è¿­ä»£å™¨çš„ä¸€é¡¹
                    // è¿”å›ç»“æœåŒ…è£¹åœ¨Someé‡Œ
                    // è¿­ä»£ç»“æŸï¼Œè¿”å›None 
                    // å¯ç›´æ¥åœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨nextæ–¹æ³•
                // å‡ ä¸ªè¿­ä»£æ–¹æ³•çš„åŒºåˆ«
                    // iteræ–¹æ³•ï¼šåœ¨ä¸å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
                    // iter_mutæ–¹æ³•ï¼šåœ¨å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
                    // into_iteræ–¹æ³•ï¼šåˆ›å»ºçš„è¿­ä»£å™¨ä¼šè·å¾—æ‰€æœ‰æƒå¹¶é”€æ¯åŸå§‹å€¼
                // æ¶ˆè€—è¿­ä»£å™¨çš„æ–¹æ³•
                    // åœ¨æ ‡å‡†åº“ä¸­ï¼Œ Iterator trait æœ‰ä¸€äº›å¸¦é»˜è®¤å®ç°çš„æ–¹æ³•
                    // å…¶ä¸­æœ‰ä¸€äº›æ–¹æ³•ä¼šè°ƒç”¨ next æ–¹æ³•
                        // å®ç° Iterator trait æ—¶å¿…é¡»å®ç° next æ–¹æ³•çš„åŸå› ä¹‹ä¸€
                    // è°ƒç”¨ next çš„æ–¹æ³•å«åš"æ¶ˆè€—å‹é€‚é…å™¨"
                        // å› ä¸ºè°ƒç”¨å®ƒä»¬ä¼šæŠŠè¿­ä»£å™¨æ¶ˆè€—å°½
                    // ä¾‹å¦‚ï¼š sum æ–¹æ³•ï¼ˆå°±ä¼šè€—å°½è¿­ä»£å™¨ï¼‰
                        // å–å¾—è¿­ä»£å™¨çš„æ‰€æœ‰æƒ
                        // é€šè¿‡åå¤è°ƒç”¨ next ï¼Œéå†æ‰€æœ‰å…ƒç´ 
                        // æ¯æ¬¡è¿­ä»£ï¼ŒæŠŠå½“å‰å…ƒç´ æ·»åŠ åˆ°ä¸€ä¸ªæ€»å’Œé‡Œï¼Œè¿­ä»£ç»“æŸï¼Œè¿”å›æ€»å’Œ
                            // iterator_run()
                // äº§ç”Ÿå…¶å®ƒè¿­ä»£å™¨çš„æ–¹æ³•
                    // å®šä¹‰åœ¨ Iterator trait ä¸Šçš„å¦å¤–ä¸€äº›æ–¹æ³•å«åš"è¿­ä»£å™¨é€‚é…å™¨"
                        // æŠŠè¿­ä»£å™¨è½¬æ¢ä¸ºä¸åŒç§ç±»çš„è¿­ä»£å™¨
                    // å¯ä»¥é€šè¿‡é“¾å¼è°ƒç”¨ä½¿ç”¨å¤šä¸ªè¿­ä»£å™¨é€‚é…å™¨æ¥æ‰§è¡Œå¤æ‚çš„æ“ä½œï¼Œè¿™ç§è°ƒç”¨å¯è¯»æ€§è¾ƒé«˜ã€‚
                    // ä¾‹å¦‚ï¼š map 
                        // æ¥æ”¶ä¸€ä¸ªé—­åŒ…ï¼Œé—­åŒ…ä½œç”¨äºæ¯ä¸ªå…ƒç´ 
                        // äº§ç”Ÿä¸€ä¸ªæ–°çš„è¿­ä»£å™¨
                    // collect æ–¹æ³•ï¼šæ¶ˆè€—å‹é€‚é…å™¨ï¼ŒæŠŠç»“æœæ”¶é›†åˆ°ä¸€ä¸ªé›†åˆç±»å‹ä¸­ã€‚
                        // let v1 = vec![1,2,3,4,5];
                        // let v3: Vec<_> = v1.iter().map(|x| x * 2).collect();
                        // println!("{:?}", v3)
                // ä½¿ç”¨é—­åŒ…æ•è·ç¯å¢ƒ
                    // filteræ–¹æ³•ï¼Œæ¥æ”¶ä¸€ä¸ªé—­åŒ…ï¼Œè¿™ä¸ªé—­åŒ…åœ¨éå†è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ æ—¶ï¼Œè¿”å›boolç±»å‹ï¼Œå¦‚æœè¿”å›trueï¼Œåˆ™ä¿ç•™è¯¥å…ƒç´ ï¼Œå¦åˆ™ä¸¢å¼ƒã€‚
                        // let shoes = vec![
                        //     Shoe { size: 10, style: String::from("sneaker") },
                        //     Shoe { size: 13, style: String::from("sandal") },
                        //     Shoe { size: 10, style: String::from("boot") },
                        // ];
                        // let in_my_size = shoes_in_size(shoes, 10);
                        // println!("in_my_size: {:?}", in_my_size)
                // ä½¿ç”¨Iterator traitæ¥åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨
                    // æä¾›ä¸€ä¸ªnextæ–¹æ³•çš„å®ç°
                        // let mut counter = Counter::new();
                        // println!("{:?}", counter.next());
                        // println!("{:?}", counter.next());
                        // println!("{:?}", counter.next());
                        // println!("{:?}", counter.next());
                        // println!("{:?}", counter.next());
                        // println!("{:?}", counter.next());
                    // skip ä»ä¸‹æ ‡1å¼€å§‹
                        // let sum1: u32 = Counter::new().zip(Counter::new().skip(1))
                        //     .map(|(a, b)| a * b).filter(|x| x % 3 == 0)
                        //     .sum();
                        // println!("{}", sum1)
        /* Cargo */
            // release profile
                // æ˜¯é¢„å®šä¹‰çš„
                // å¯è‡ªå®šä¹‰ï¼šå¯ä½¿ç”¨ä¸åŒçš„é…ç½®ï¼Œå¯¹ä»£ç ç¼–è¯‘æ‹¥æœ‰æ›´å¤šçš„æ§åˆ¶
                // æ¯ä¸ª profile çš„é…ç½®éƒ½ç‹¬ç«‹äºå…¶å®ƒçš„ profile 
            // Cargo ä¸»è¦çš„ä¸¤ä¸ª profile :
                // dev profile ï¼šé€‚ç”¨äºå¼€å‘ï¼Œ cargo build 
                // release profile ï¼šé€‚ç”¨äºå‘å¸ƒï¼Œ cargo build - release
            // è‡ªå®šä¹‰ profile 
                // é’ˆå¯¹æ¯ä¸ª profile , Cargo éƒ½æä¾›äº†é»˜è®¤çš„é…ç½®
                // å¦‚æœæƒ³è‡ªå®šä¹‰ xxxx profile çš„é…ç½®ï¼š
                    // å¯ä»¥åœ¨ Cargo . toml é‡Œæ·»åŠ ï¼» profile . xxxx ï¼½åŒºåŸŸï¼Œåœ¨é‡Œé¢è¦†ç›–é»˜è®¤é…ç½®çš„å­é›†
                // å¯¹äºæ¯ä¸ªé…ç½®çš„é»˜è®¤å€¼å’Œå®Œæ•´é€‰é¡¹ï¼Œè¯·å‚è§ï¼šhttps://doc.rust-lang.org/cargo/.
            // ç”Ÿæˆ HTML æ–‡æ¡£çš„å‘½ä»¤
            // cargo docï¼š  å®ƒä¼šè¿è¡Œ rustdoc å·¥å…·ï¼ˆ Rust å®‰è£…åŒ…è‡ªå¸¦ï¼‰
                // æŠŠç”Ÿæˆçš„ HTML æ–‡æ¡£æ”¾åœ¨ target / doc ç›®å½•ä¸‹. 
            // cargo doc - open : æ„å»ºå½“å‰ crate çš„æ–‡æ¡£ï¼ˆä¹ŸåŒ…å« crate ä¾èµ–é¡¹çš„æ–‡æ¡£ï¼‰
                // åœ¨æµè§ˆå™¨æ‰“å¼€æ–‡æ¡£
        /* æ™ºèƒ½æŒ‡é’ˆ */
            // æŒ‡é’ˆï¼šä¸€ä¸ªå˜é‡åœ¨å†…å­˜ä¸­åŒ…å«çš„æ˜¯ä¸€ä¸ªåœ°å€ï¼ˆæŒ‡å‘å…¶ä»–æ•°æ®ï¼‰
            // Rustä¸­æœ€å¸¸è§çš„æŒ‡é’ˆå°±æ˜¯â€œå¼•ç”¨â€ï¼šä½¿ç”¨&ï¼Œå€Ÿç”¨å®ƒæŒ‡å‘çš„å€¼ï¼Œæ²¡æœ‰å…¶ä½™å¼€é”€ï¼Œæœ€å¸¸è§çš„æŒ‡é’ˆç±»å‹
            // æ™ºèƒ½æŒ‡é’ˆï¼šæ™ºèƒ½æŒ‡é’ˆçš„è¡Œä¸ºå’ŒæŒ‡é’ˆç›¸ä¼¼ï¼Œæœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½
            // å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰æ™ºèƒ½æŒ‡é’ˆç±»å‹
                // é€šè¿‡è®°å½•æ‰€æœ‰è€…çš„æ•°é‡ï¼Œä½¿ä¸€ä»½æ•°æ®è¢«å¤šä¸ªæ‰€æœ‰è€…åŒäº‹æŒæœ‰
                // å¹¶åœ¨æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶è‡ªåŠ¨æ¸…ç†æ•°æ®
            // å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„ä¸åŒ
                // å¼•ç”¨ï¼šåªå€Ÿç”¨æ•°æ®
                // æ™ºèƒ½æŒ‡é’ˆï¼šæ‹¥æœ‰æ•°æ®ï¼Œå¹¶å…è®¸è®¿é—®æ•°æ®
            // æ™ºèƒ½æŒ‡é’ˆçš„ä¾‹å­
                // String å’Œ Vec < T >
                // éƒ½æ‹¥æœ‰ä¸€ç‰‡å†…å­˜åŒºåŸŸï¼Œä¸”å…è®¸ç”¨æˆ·å¯¹å…¶æ“ä½œ
                // è¿˜æ‹¥æœ‰å…ƒæ•°æ®ï¼ˆä¾‹å¦‚å®¹é‡ç­‰ï¼‰
                // æä¾›é¢å¤–çš„åŠŸèƒ½æˆ–ä¿éšœï¼ˆ String ä¿éšœå…¶æ•°æ®æ˜¯åˆæ³•çš„ UTF -8ç¼–ç ï¼‰
            // æ™ºèƒ½æŒ‡é’ˆçš„å®ç°
                // æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨structå®ç°ï¼Œå¹¶ä¸”å®ç°äº†Deref å’Œ Drop è¿™ä¸¤ä¸ªtrait
                // Deref traitï¼šå®ç° Deref trait çš„ç±»å‹ï¼Œå½“é€šè¿‡ * è¿ç®—ç¬¦è®¿é—®å…¶å€¼æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ Deref trait çš„ deref æ–¹æ³•ï¼Œå…è®¸æ™ºèƒ½æŒ‡é’ˆstructçš„å®ä¾‹åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨
                // Drop traitï¼šå®ç° Drop trait çš„ç±»å‹ï¼Œå½“å…¶è¢«ä¸¢å¼ƒæ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ Drop trait çš„ drop æ–¹æ³•ï¼Œå…è®¸æ™ºèƒ½æŒ‡é’ˆstructçš„å®ä¾‹åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶æ‰§è¡Œä¸€äº›æ¸…ç†å·¥ä½œ
            // å¸¸è§çš„æ™ºèƒ½æŒ‡é’ˆ
                // Box < T >ï¼šBox < T > æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒå…è®¸åœ¨å †ä¸Šåˆ†é…æ•°æ®ï¼Œè€Œä¸æ˜¯åœ¨æ ˆä¸Šã€‚
                // Rc < T >ï¼šRc < T > æ˜¯ä¸€ä¸ªå¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œå…è®¸åœ¨å¤šä¸ªåœ°æ–¹æ‹¥æœ‰å¯¹åŒä¸€æ•°æ®çš„å¼•ç”¨ã€‚
                // Ref<T> å’Œ RefMut < T >ï¼Œ é€šè¿‡RefCell < T >è®¿é—®ï¼Œåœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯ç¼–è¯‘æ—¶ï¼Œæƒ…æ‰§å€Ÿç”¨è§„åˆ™çš„ç±»å‹
                // æ­¤å¤–ï¼Œå†…éƒ¨å¯å˜æ¨¡å¼ï¼šä¸å¯å˜ç±»å‹æš´éœ²å‡ºå¯ä¿®æ”¹å…¶å†…éƒ¨å€¼çš„API
                // å¾ªç¯å¼•ç”¨ï¼šå¦‚ä½•å¯¼è‡´å†…å­˜æ³„æ¼ï¼Œä»¥åŠå¦‚ä½•é˜²æ­¢å…¶å‘ç”Ÿ
            // ä½¿ç”¨Box < T >æ¥æŒ‡å‘heapå †å†…å­˜ä¸Šçš„æ•°æ®
                // æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå…è®¸ä½ åœ¨heapä¸Šå­˜å‚¨æ•°æ®ï¼ˆè€Œä¸æ˜¯stackï¼‰
                // stackä¸ŠæŒ‡å‘heapæ•°æ®çš„æŒ‡é’ˆ
                // æ²¡æœ‰æ€§èƒ½å¼€é”€ï¼Œæ²¡æœ‰é¢å¤–åŠŸèƒ½
                // å®ç°äº†Deref trait å’Œ Drop trait
                // Box < T >çš„å¸¸ç”¨åœºæ™¯
                    // åœ¨ç¼–è¯‘æ—¶ï¼ŒæŸç±»å‹çš„å¤§å°æ— æ³•ç¡®å®šã€‚ä½†ä½¿ç”¨è¯¥ç±»å‹æ—¶ï¼Œä¸Šä¸‹æ–‡å´éœ€è¦çŸ¥é“å®ƒçš„ç¡®åˆ‡å¤§å°ã€‚
                    // å½“ä½ æœ‰å¤§é‡æ•°æ®ï¼Œæƒ³ç§»äº¤æ‰€æœ‰æƒï¼Œä½†éœ€è¦ç¡®ä¿åœ¨æ“ä½œæ—¶æ•°æ®ä¸ä¼šè¢«å¤åˆ¶ã€‚
                    // ä½¿ç”¨æŸä¸ªå€¼æ—¶ï¼Œä½ åªå…³å¿ƒå®ƒæ˜¯å¦å®ç°äº†ç‰¹å®šçš„ trait ï¼Œè€Œä¸å…³å¿ƒå®ƒçš„å…·ä½“ç±»å‹ã€‚
                // ä½¿ç”¨Boxèµ‹å€¼èƒ½é€’å½’ç±»å‹
                    // åœ¨ç¼–è¯‘æ—¶ï¼ŒRustéœ€è¦çŸ¥é“ä¸€ä¸ªç±»å‹æ‰€å çš„ç©ºé—´å¤§å°ï¼Œè€Œé€’å½’ç±»å‹çš„å¤§å°æ— æ³•å†ç¼–è¯‘æ—¶ç¡®å®šï¼Œä½†Boxç±»å‹çš„å¤§å°ç¡®å®šï¼Œåœ¨é€’å½’ç±»å‹ä¸­ä½¿ç”¨Boxå°±å¯è§£å†³ä¸Šè¿°é—®é¢˜
                    // ç±»ä¼¼å‡½æ•°å¼è¯­è¨€ä¸­çš„Cons List
                        // Cons List æ˜¯æ¥è‡ª Lisp è¯­è¨€çš„ä¸€ç§æ•°æ®ç»“æ„ã€‚
                            // Cons List é‡Œæ¯ä¸ªæˆå‘˜ç”±ä¸¤ä¸ªå…ƒç´ ç»„æˆã€‚
                                // å½“å‰é¡¹çš„å€¼
                                // ä¸‹ä¸€ä¸ªå…ƒç´ 
                            // Cons List é‡Œæœ€åä¸€ä¸ªæˆå‘˜åªåŒ…å«ä¸€ä¸ª Nil å€¼ï¼Œæ²¡æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
                                // let list1 = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
                                // println!("{:?}", list1)
                // ä½¿ç”¨ Box æ¥è·å¾—ç¡®å®šå¤§å°çš„é€’å½’ç±»å‹
                    // Box < T ï¼æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œ Rust çŸ¥é“å®ƒéœ€è¦å¤šå°‘ç©ºé—´ï¼Œå› ä¸ºï¼šæŒ‡é’ˆçš„å¤§å°ä¸ä¼šåŸºäºå®ƒæŒ‡å‘çš„æ•°æ®çš„å¤§å°å˜åŒ–è€Œå˜åŒ–ã€‚
                    // Box < T >:
                        // åªæä¾›äº†"é—´æ¥"å­˜å‚¨å’Œ heap å†…å­˜åˆ†é…çš„åŠŸèƒ½,æ²¡æœ‰å…¶å®ƒé¢å¤–åŠŸèƒ½,æ²¡æœ‰æ€§èƒ½å¼€é”€
                        // é€‚ç”¨äºéœ€è¦"é—´æ¥"å­˜å‚¨çš„åœºæ™¯ï¼Œä¾‹å¦‚ Cons List -å®ç°äº† Deref trait å’Œ Drop trait
            // Deref trait
                // å®ç°Deref trait çš„ç±»å‹ï¼Œå½“é€šè¿‡ * è¿ç®—ç¬¦è®¿é—®å…¶å€¼æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ Deref trait çš„ deref æ–¹æ³•ï¼Œå…è®¸æ™ºèƒ½æŒ‡é’ˆstructçš„å®ä¾‹åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨ï¼Œå¯ä»¥è‡ªå®šä¹‰è§£å¼•ç”¨è¿ç®—ç¬¦*çš„è¡Œä¸º
                // è§£å¼•ç”¨è¿ç®—ç¬¦
                    // let x = 3;
                    // // let y = &x;
                    // let y = Box::new(x);
                    // println!("{}", x == 3);
                    // println!("{}", *y == 3);
                // è‡ªå®šä¹‰è§£å¼•ç”¨è¿ç®—ç¬¦
                    // let x = 3;
                    // let y = my_box(x);
                    // println!("{}", x == 3);
                    // println!("{}", *y == 3);  // *y ç›¸å½“äº *(y.deref())
                // å‡½æ•°å’Œæ–¹æ³•çš„éšå¼è§£å¼•ç”¨è½¬åŒ–(Deref Coercion)
                    // éšå¼è§£å¼•ç”¨è½¬åŒ–æ˜¯ä¸ºå‡½æ•°å’Œæ–¹æ³•æä¾›çš„ä¸€ç§ä¾¿æ·ç‰¹æ€§
                    // å‡è®¾ T å®ç°äº† Deref trait :
                        // Deref Coercion å¯ä»¥æŠŠ T çš„å¼•ç”¨è½¬åŒ–ä¸º T ç»è¿‡ Deref æ“ä½œåç”Ÿæˆçš„å¼•ç”¨
                    // å½“æŠŠæŸç±»å‹çš„å¼•ç”¨ä¼ é€’ç»™å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œä½†å®ƒçš„ç±»å‹ä¸å®šä¹‰çš„å‚æ•°ç±»å‹ä¸åŒ¹é…ï¼š
                        // Deref Coercion å°±ä¼šè‡ªåŠ¨å‘ç”Ÿ
                        // ç¼–è¯‘å™¨ä¼šå¯¹ deref è¿›è¡Œä¸€ç³»åˆ—è°ƒç”¨ï¼Œæ¥æŠŠå®ƒè½¬ä¸ºæ‰€éœ€çš„å‚æ•°ç±»å‹
                        // åœ¨ç¼–è¯‘æ—¶å®Œæˆï¼Œæ²¡æœ‰é¢å¤–æ€§èƒ½å¼€é”€
                            // let m = MyBox(String::from("hello"));
                            // hello(&m); // 1. &m &MyBox<String> å®ç°äº†Deref trait ï¼Œæ‰€ä»¥ &m å¯ä»¥è½¬åŒ–ä¸º &String. 2. &String ä¹Ÿå®ç°äº† Deref trait ï¼Œæ‰€ä»¥ &String å¯ä»¥è½¬åŒ–ä¸º &strã€‚ Rustä¼šä¸€ç›´è°ƒç”¨derefè¿™ä¸ªæ–¹æ³•
                            // hello("dss");
                // è§£å¼•ç”¨ä¸å¯å˜æ€§
                    // å¯ä½¿ç”¨DerefMut traité‡è½½å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦
                    // åœ¨ç±»å‹å’Œtraitåœ¨ä¸‹åˆ—ä¸‰ç§æƒ…å†µå‘ç”Ÿæ—¶ï¼ŒRustä¼šæ‰§è¡ŒDeref Coercion
                        // å½“T: Deref<Targrt=U>,å…è®¸&Tè½¬åŒ–ä¸º&U
                        // å½“T: DerefMut<Target=U>,å…è®¸&mut Tè½¬åŒ–ä¸º&mut U
                        // å½“T: Deref<Target=U>,å…è®¸&mut Tè½¬åŒ–ä¸º&U
            // Drop trait
                // å®ç° Drop Trait ï¼Œå¯ä»¥è®©æˆ‘ä»¬è‡ªå®šä¹‰å½“å€¼å°†è¦ç¦»å¼€ä½œç”¨åŸŸæ—¶å‘ç”Ÿçš„åŠ¨ä½œã€‚
                    // ä¾‹å¦‚ï¼šæ–‡ä»¶ã€ç½‘ç»œèµ„æºé‡Šæ”¾ç­‰
                    // ä»»ä½•ç±»å‹éƒ½å¯ä»¥å®ç° Drop trait 
                    // Drop trait åªè¦æ±‚ä½ å®ç° drop æ–¹æ³•ï¼šå‚æ•°ï¼šå¯¹ self çš„å¯å˜å¼•ç”¨
                    // Drop trait åœ¨é¢„å¯¼å…¥æ¨¡å—é‡Œï¼ˆ prelude )
                        // let cc = CustomStruct {
                        //     data: String::from("æ±‡æº"),
                        // };
                        // drop(cc);
                        // let gg = CustomStruct {
                        //     data: String::from("æœæ±"),
                        // };
                // ä½¿ç”¨ std :: mem :: drop æ¥æå‰ drop å€¼
                    // Â·å¾ˆéš¾ç›´æ¥ç¦ç”¨è‡ªåŠ¨çš„ drop åŠŸèƒ½ï¼Œä¹Ÿæ²¡å¿…è¦
                    // - Drop trait çš„ç›®çš„å°±æ˜¯è¿›è¡Œè‡ªåŠ¨çš„é‡Šæ”¾å¤„ç†é€»è¾‘
                    // . Rust ä¸å…è®¸æ‰‹åŠ¨è°ƒç”¨ Drop trait çš„ drop æ–¹æ³•
                    // ï¼ä½†å¯ä»¥è°ƒç”¨æ ‡å‡†åº“çš„ std :: mem :: drop å‡½æ•°ï¼Œæ¥æå‰ drop å€¼
            // Rc<T> 
                // Rc<T> æ˜¯ä¸€ä¸ªå¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼Œå…è®¸å¤šä¸ª ownership,ä¸€ä¸ªå€¼ä¼šæœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¼šæœ‰å¤šä¸ªè¦ç´ æŒ‡å‘å®ƒ
                // ä¸ºäº†æ”¯æŒå¤šé‡æ‰€æœ‰æƒï¼ŒRc<T> reference countingï¼ˆå¼•ç”¨è®¡æ•°ï¼‰ï¼Œä¼šè¿½è¸ªæ‰€æœ‰åˆ°å€¼çš„å¼•ç”¨ï¼Œå½“0ä¸ªå¼•ç”¨æ—¶å°±ä»£è¡¨è¯¥å€¼å¯ä»¥è¢«æ¸…ç†æ‰
                // ä½¿ç”¨åœºæ™¯
                    // éœ€è¦åœ¨heapä¸Šåˆ†é…æ•°æ®ï¼Œè¿™äº›æ•°æ®è¢«ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†è¯»å–ï¼ˆåªè¯»ï¼‰ï¼Œä½†åœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå“ªä¸ªéƒ¨åˆ†æœ€åä½¿ç”¨å®Œè¿™äº›æ•°æ®
                    // RC<T> åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯
                    // Rc<T> ä¸åœ¨é¢„å¯¼å…¥æ¨¡å—ä¸­ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨å¯¼å…¥
                    // Rc::clone(&a)å‡½æ•°ï¼šå¢åŠ å¼•ç”¨è®¡æ•°
                    // Rc::strong_count(&a)å‡½æ•°ï¼šè·å–å¼•ç”¨è®¡æ•°
                    // Rc::weak_count(&a)å‡½æ•°ï¼šè·å–å¼±å¼•ç”¨è®¡æ•°
                        // let aaa = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
                        // println!("aaa å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aaa));
                        // let _bbb = Cons(3, Rc::clone(&aaa));
                        // println!("aaa å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aaa));
                        // {
                        //     let _ccc = Cons(4, Rc::clone(&aaa));
                        //     println!("aaa å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aaa));
                        // }
                        // println!("aaa åœ¨ç¦»å¼€ä½œç”¨åŸŸä¹‹åçš„å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aaa))
                    // Rc::clone(&a) å’Œ ç±»å‹çš„clone()æ–¹æ³•
                            // Rc::cloneä¸ä¼šæ‰§è¡Œæ•°æ®çš„æ·±åº¦æ‹·è´æ“ä½œï¼Œåªä¼šå¢åŠ å¼•ç”¨çš„è®¡æ•°
                            // ç±»å‹çš„clone()æ–¹æ³•å¾ˆå¤šä¼šæ‰§è¡Œæ•°æ®çš„æ·±åº¦æ‹·è´æ“ä½œ
                        // let aa = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
                        // aa.clone();  // ä¼šå¢åŠ å¼•ç”¨è®¡æ•° å’Œ Rc::cloneåŒºåˆ«åœ¨ï¼ŒRc::cloneä¸ä¼šæ‰§è¡Œæ•°æ®çš„æ·±åº¦æ‹·è´æ“ä½œï¼Œåªä¼šå¢åŠ å¼•ç”¨çš„è®¡æ•°
                        // let bb = Cons(3, Rc::clone(&aa));
                        // let cc = Cons(4, Rc::clone(&aa));
                    // Rc<T>é€šè¿‡ä¸å¯å˜å¼•ç”¨ï¼Œæ˜¯ä½ å¯ä»¥åœ¨ç¨‹åºä¸åŒéƒ¨åˆ†ä¹‹é—´å…±äº«åªè¯»æ•°æ®
            // RefCell<T> å’Œå†…éƒ¨å¯å˜æ€§
                // å†…éƒ¨å¯å˜æ€§æ˜¯Rustçš„è®¾è®¡æ¨¡å¼ä¹‹ä¸€
                // å®ƒå…è®¸ä½ åœ¨åªæŒæœ‰ä¸å¯å˜å¼•ç”¨çš„å‰æä¸‹å¯¹æ•°æ®è¿›è¡Œä¿®æ”¹ï¼Œæ•°æ®ç»“æ„ä¸­ä½¿ç”¨äº†unsafeä»£ç æ¥ç»•è¿‡Rustæ­£å¸¸çš„å¯å˜æ€§å’Œå€Ÿç”¨è§„åˆ™
                // åªèƒ½ç”¨äºå•çº¿ç¨‹çš„åœºæ™¯
                // Box<T> å’Œ RefCell<T> çš„åŒºåˆ«
                    // Box<T>ï¼šç¼–è¯‘é˜¶æ®µå¼ºåˆ¶ä»£ç éµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œå¦åˆ™å°±å‡ºç°é”™è¯¯
                    // RefCell<T>ï¼šåªä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™ï¼Œå¦åˆ™è§¦å‘panic
                // RefCell<T>çš„ä¸¤ä¸ªæ–¹æ³•ï¼ˆå®‰å…¨æ¥å£ï¼‰
                    // borrow() å’Œ borrow_mut() éƒ½æ˜¯è¿”å›ä¸€ä¸ªRc<T>çš„æ™ºèƒ½æŒ‡é’ˆï¼Œä½†borrow()è¿”å›çš„æ˜¯ä¸€ä¸ªä¸å¯å˜çš„å¼•ç”¨ï¼Œborrow_mut()è¿”å›çš„æ˜¯ä¸€ä¸ªå¯å˜çš„å¼•ç”¨
                    //  RefCell<T>ä¼šè®°å½•å½“å‰å­˜åœ¨å¤šå°‘ä¸ªæ´»è·ƒçš„Ref<T>å’Œ RefMut<T>æ™ºèƒ½æŒ‡é’ˆ
                        // æ¯æ¬¡è°ƒç”¨borrowï¼šä¸å¯å˜å€Ÿç”¨è®¡æ•°+1
                        // ä»»ä½•ä¸€ä¸ªRef<T>çš„å€¼ç¦»å¼€ä½œç”¨åŸŸè¢«é‡Šæ”¾æ—¶ï¼šä¸å¯å˜å€Ÿç”¨è®¡æ•°-1
                        // æ¯æ¬¡è°ƒç”¨borrow_mutï¼šå¯å˜å€Ÿç”¨è®¡æ•°+1
                        // ä»»ä½•ä¸€ä¸ªRefMut<T>çš„å€¼ç¦»å¼€ä½œç”¨åŸŸè¢«é‡Šæ”¾æ—¶ï¼šå¯å˜å€Ÿç”¨è®¡æ•°-1
                            // let value = Rc::new(RefCell::new(5));
                            // let aaaa = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
                            // let bbbb = Cons(Rc::new(RefCell::new(6)), Rc::clone(&aaaa));
                            // let cccc = Cons(Rc::new(RefCell::new(10)), Rc::clone(&aaaa));
                            // *value.borrow_mut() += 10;
                            // println!("aaaa after = {:?}", aaaa);
                            // println!("bbb after = {:?}", bbbb);
                            // println!("cccc after = {:?}", cccc); 
                    // å…¶ä»–æ–¹æ³•
                        // Cell<T>ï¼šé€šè¿‡å¤åˆ¶æ¥è®¿é—®æ•°æ®
                        // Mutex<T>ï¼šç”¨äºå®ç°è·¨çº¿ç¨‹æƒ…å†µä¸‹çš„å†…éƒ¨å¯å˜æ€§æ¨¡å¼
                // Rustå¾ªç¯å¼•ç”¨å¯èƒ½ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼
                    // Rustçš„å†…å­˜å®‰å…¨æœºåˆ¶å¯ä»¥ä¿è¯å¾ˆéš¾å‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œä½†ä¸æ˜¯ä¸å¯èƒ½
                    // ä¾‹å¦‚ä½¿ç”¨Rc<T>å’ŒRefCell<T>å°±å¯èƒ½åˆ›é€ å‡ºå¾ªç¯å¼•ç”¨ï¼Œä»è€Œå‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œå› ä¸ºæ¯ä¸ªé¡¹çš„å¼•ç”¨æ•°é‡éƒ½ä¸ä¼šå˜æˆ0ï¼Œå€¼ä¹Ÿå°±ä¸ä¼šè¢«å¤„ç†
                        // let aa = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));
                        // println!("aaçš„å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aa));  // 1
                        // println!("aaçš„ä¸‹ä¸€ä¸ªitem = {:?}", aa.tail());  // Some(RefCell { value: Nil })
                        // let bb = Rc::new(Cons(10, RefCell::new(Rc::clone(&aa))));
                        // println!("aaçš„å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aa));  // 2
                        // println!("bbçš„å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&bb));  // 1
                        // println!("bbçš„ä¸‹ä¸€ä¸ªitem = {:?}", bb.tail());  // Some(RefCell { value: Cons(5, RefCell { value: Nil }) })

                        // if let Some(link) =  aa.tail(){
                        //     // æŠŠaaçš„ç¬¬äºŒä¸ªå…ƒç´ nextæŒ‡å‘bb
                        //     *link.borrow_mut() = Rc::clone(&bb);
                        // }
                        // println!("aaçš„å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&aa)); // 2
                        // println!("bbçš„å¼ºå¼•ç”¨ä¸ªæ•° = {}", Rc::strong_count(&bb));  // 2
                // é˜²æ­¢å¾ªç¯å¼•ç”¨ï¼ŒæŠŠRc<T>æ›¿æ¢ä¸ºWeak<T>
                    // Rc::clone()ä¸ºRc<T>å®ä¾‹çš„strong_count+1ï¼Œå¢åŠ å¼•ç”¨è®¡æ•°ï¼ŒRc<T>å®ä¾‹åªæœ‰åœ¨strong_countä¸º0æ—¶å€™æ‰ä¼šè¢«æ¸…ç†
                    // Rc<T>å®ä¾‹é€šè¿‡è°ƒç”¨Rc::downgrade()æ–¹æ³•ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªWeak<T>å®ä¾‹(å¼±å¼•ç”¨)ï¼ŒWeak<T>å®ä¾‹ä¸ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè¿”å›çš„ç±»å‹æ˜¯Weak<T>(æ™ºèƒ½æŒ‡é’ˆ)
                    // è°ƒç”¨Rc::downgrade ä¼šä¸º weak_count +1
                    // Rc<T>ä½¿ç”¨weak_coumtæ¥è¿½è¸ªå­˜åœ¨å¤šå°‘Weak<T>å®ä¾‹
                    // weak_count ä¸ä¸º0å¹¶ä¸å½±å“Rc<T>å®ä¾‹çš„æ¸…ç†
                // Strong vs Weak 
                    // Strong Reference ï¼ˆå¼ºå¼•ç”¨ï¼‰æ˜¯å…³äºå¦‚ä½•åˆ†äº« Rc < T ï¼å®ä¾‹çš„æ‰€æœ‰æƒ. Weak Reference ï¼ˆå¼±å¼•ç”¨ï¼‰å¹¶ä¸è¡¨è¾¾ä¸Šè¿°æ„æ€
                // ä½¿ç”¨ Weak Reference å¹¶ä¸ä¼šåˆ›å»ºå¾ªç¯å¼•ç”¨ï¼š
                    // å½“ Strong Reference æ•°é‡ä¸º0çš„æ—¶å€™ï¼Œ Weak Reference ä¼šè‡ªåŠ¨æ–­å¼€.åœ¨ä½¿ç”¨ Weak < T ï¼å‰ï¼Œéœ€ä¿è¯å®ƒæŒ‡å‘çš„å€¼ä»ç„¶å­˜åœ¨ï¼š
                    // åœ¨ Weak < T ï¼å®ä¾‹ä¸Šè°ƒç”¨ upgrade æ–¹æ³•ï¼Œè¿”å› Option < Rc < T >>
                            // let leaf = Rc::new(Node{
                            //     value: 5,
                            //     parent: RefCell::new(Weak::new()),
                            //     children: RefCell::new(vec![])
                            // });
                            // let branch = Rc::new(Node{
                            //     value: 10,
                            //     parent: RefCell::new(Weak::new()),
                            //     children: RefCell::new(vec![Rc::clone(&leaf)])
                            // });
                            // // borrow() è·å¾—ä¸å¯å˜å¼•ç”¨ï¼Œupgrade() è·å¾—å¯å˜å¼•ç”¨-->æŠŠWeak<T>è½¬æ¢æˆRc<T>
                            // println!("keaf parent = {:?}", leaf.parent.borrow().upgrade());
                            // //  æŠŠleafçš„çˆ¶èŠ‚ç‚¹æŒ‡å‘branchï¼Œé€šè¿‡downgradeæ–¹æ³•ï¼ŒæŠŠbranchçš„Rc<Node>è½¬æ¢æˆWeak<Node>
                            // *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
                            // println!("keaf parent ç°åœ¨ = {:?}", leaf.parent.borrow().upgrade());
                            // println!("{:?}", branch)
                    // å½“å¼ºå¼•ç”¨è¢«ä¸¢å¼ƒæ—¶ï¼Œå¼±å¼•ç”¨å³ä¾¿æœ‰å¼•ç”¨ï¼Œä¹Ÿä¼šè¢«ä¸¢å¼ƒ
                        // let leaf = Rc::new(Node{
                        //     value: 5,
                        //     parent: RefCell::new(Weak::new()),
                        //     children: RefCell::new(vec![])
                        // });
                        // println!("keaf strong = {}, weak = {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf));
                        // {
                        //     let branch = Rc::new(Node{
                        //         value: 10,
                        //         parent: RefCell::new(Weak::new()),
                        //         children: RefCell::new(vec![Rc::clone(&leaf)])
                        //     });
                           
                        //     //  æŠŠleafçš„çˆ¶èŠ‚ç‚¹æŒ‡å‘branchï¼Œé€šè¿‡downgradeæ–¹æ³•ï¼ŒæŠŠbranchçš„Rc<Node>è½¬æ¢æˆWeak<Node>
                        //     *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
                        //     println!("branch strong = {}, weak = {}", Rc::strong_count(&branch), Rc::weak_count(&branch));
                        //     println!("keaf strong = {}, weak = {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf));
                        // }
                        // println!("keaf parent = {:?}", leaf.parent.borrow().upgrade());
                        // println!("keaf strong = {}, weak = {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf));
        /* å¹¶å‘ */
            // councurrent: ç¨‹åºçš„ä¸åŒéƒ¨åˆ†ä¹‹é—´ç‹¬ç«‹æ‰§è¡Œï¼Œäº’ä¸å¹²æ‰°
            // parallel: ç¨‹åºçš„ä¸åŒéƒ¨åˆ†åŒæ—¶æ‰§è¡Œ
            // Rustä¸­ï¼Œå¹¶å‘ç¼–ç¨‹é€šè¿‡çº¿ç¨‹æ¥å®ç°ï¼Œçº¿ç¨‹æ˜¯Rustä¸­å¹¶å‘ç¼–ç¨‹çš„åŸºæœ¬å•å…ƒ
            // æ³¨æ„ï¼Œæœ¬æ–‡ä¸­çš„â€å¹¶å‘â€œæ³›æŒ‡ concurrent å’Œ parallel

            // ä½¿ç”¨çº¿ç¨‹åŒæ—¶è¿è¡Œä»£ç 
                // è¿›ç¨‹è·Ÿçº¿ç¨‹
                    // å¤§éƒ¨åˆ†OSé‡Œï¼Œä»£ç è¿è¡Œåœ¨è¿›ç¨‹(process)ä¸­ï¼ŒOSåŒæ—¶ç®¡ç†å¤šä¸ªè¿›ç¨‹ï¼Œåœ¨ç¨‹åºé‡Œï¼Œå„ç‹¬ç«‹éƒ¨åˆ†å¯ä»¥åŒæ—¶è¿è¡Œï¼Œè¿è¡Œè¿™äº›ç‹¬ç«‹éƒ¨åˆ†çš„å°±æ˜¯çº¿ç¨‹ï¼ˆthresdï¼‰
                    // å¤šçº¿ç¨‹è¿è¡Œï¼Œæå‡æ€§èƒ½ï¼Œä½†æ˜¯ä¼šå¢åŠ å¤æ‚æ€§ï¼Œå› ä¸ºæ— æ³•ä¿éšœå„çº¿ç¨‹çš„æ‰§è¡Œé¡ºåº
                // å¤šçº¿ç¨‹å¯å¯¼è‡´çš„é—®é¢˜
                    // ç«äº‰çŠ¶æ€ï¼šç°æˆä»¥ä¸ä¸€è‡´çš„é¡ºåºè®¿é—®æ•°æ®æˆ–èµ„æº
                    // æ­»é”ï¼šä¸¤ä¸ªç°æˆå½¼æ­¤ç­‰å¾…å¯¹æ–¹ä½¿ç”¨å®Œæ‰€æŒæœ‰çš„èµ„æºï¼Œçº¿ç¨‹æ— æ³•ç»§ç»­
                    // åªæœ‰åœ¨æŸäº›æƒ…å†µä¸‹å‘ç”Ÿçš„Bugï¼Œå¾ˆéš¾å¯é çš„å¤ç°å’Œä¿®å¤
                // å®ç°çº¿ç¨‹çš„æ–¹å¼
                    // é€šè¿‡è°ƒç”¨OSçš„APIæ¥åˆ›å»ºçº¿ç¨‹ï¼š 1:1æ¨¡å‹--->éœ€è¦è¾ƒå°çš„è¿è¡Œæ—¶
                    // è¯­è¨€è‡ªå·±å®ç°çš„ç°æˆï¼ˆç»¿è‰²çº¿ç¨‹ï¼‰ï¼š M:N æ¨¡å‹--->éœ€è¦è¾ƒå¤§çš„è¿è¡Œæ—¶
                    // Rustæ ‡å‡†åº“ä»…æä¾›1:1æ¨¡å‹çš„çº¿ç¨‹
                    // Rustä¸­ï¼Œçº¿ç¨‹é€šè¿‡std::thread::spawn()å‡½æ•°åˆ›å»ºï¼Œå‚æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ï¼ˆåœ¨æ–°çº¿ç¨‹é‡Œè¿è¡Œçš„ä»£ç ï¼‰
                        // thread::spawn(|| {
                        //     for i in 1..10 {
                        //         println!("hi number {} from the spawned thread!", i);
                        //         // æš‚åœä¸€æ¯«ç§’
                        //         thread::sleep(Duration::from_millis(1));
                        //     }
                        // });

                        // for i in 1..5 {
                        //     println!("number {} from the main thread!", i);
                        //     thread::sleep(Duration::from_millis(1));
                        // }
                    // é€šè¿‡join Handleï¼Œç­‰å¾…çº¿ç¨‹ç»“æŸ
                        // thread::spawn å‡½æ•°çš„è¿”å›å€¼ç±»å‹æ˜¯JoinHandle
                        // JoinHandleæŒæœ‰å€¼çš„æ‰€æœ‰æƒï¼Œè°ƒç”¨å…¶Joinæ–¹æ³•ï¼Œå¯ä»¥ç­‰å¾…å¯¹åº”çš„å…¶ä»–çº¿ç¨‹çš„å®Œæˆ
                        // joinæ–¹æ³•ï¼šè°ƒç”¨Handleçš„joinæ–¹æ³•ä¼šé˜»æ­¢å½“å‰è¿è¡Œçº¿ç¨‹çš„æ‰§è¡Œï¼Œç›´åˆ°å¯¹åº”çš„çº¿ç¨‹ç»“æŸ
                            // let t = thread::spawn(|| {
                            //     for i in 1..10 {
                            //         println!("hi number {} from the spawned thread!", i);
                            //         // æš‚åœä¸€æ¯«ç§’
                            //         thread::sleep(Duration::from_millis(1));
                            //     }
                            // });

                            // for i in 1..5 {
                            //     println!("number {} from the main thread!", i);
                            //     thread::sleep(Duration::from_millis(1));
                            // }
                            // // ç­‰å¾…å­çº¿ç¨‹çš„ç»“æŸï¼Œå› ä¸ºjoinä¼šè¿”å›ä¸€ä¸ªResult<T, E>ï¼Œæ‰€ä»¥ä½¿ç”¨unwrap
                            // t.join().unwrap()
                    // ä½¿ç”¨moveé—­åŒ…
                        // moveé—­åŒ…é€šå¸¸å’Œthread::spawnä¸€èµ·ä½¿ç”¨ï¼Œå› ä¸ºé—­åŒ…ä¼šæ•è·å˜é‡çš„å¼•ç”¨ï¼Œè€Œspawnéœ€è¦é—­åŒ…è·å–å˜é‡çš„æ‰€æœ‰æƒ
                        // moveé—­åŒ…ä¼šå¼ºåˆ¶é—­åŒ…è·å–å˜é‡çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯å¼•ç”¨
                        // åˆ›å»ºçº¿ç¨‹æ—¶ï¼Œä¼šæŠŠå€¼çš„æ‰€æœ‰æƒä»ä¸€ä¸ªçº¿ç¨‹è½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹
                            // let v = vec![1, 2, 3];
                            // let handle = thread::spawn(move || {
                            //     println!("Here's a vector: {:?}", v);
                            // });
                            // // è¿™é‡Œå¦‚æœæ²¡æœ‰ç­‰å¾…ï¼Œé‚£ä¼šå‡ºç°ä¸Šé¢çš„çº¿ç¨‹é—­åŒ…å‡½æ•°è¿˜æ²¡æ¥å¾—åŠæ‰§è¡Œï¼Œvå°±å¤±æ•ˆäº†
                            // handle.join().unwrap();
            // ä½¿ç”¨æ¶ˆæ¯ä¼ é€’æ¥è·¨çº¿ç¨‹ä¼ é€’æ•°æ®
                // ä¸€ç§å¾ˆæµè¡Œä¸”èƒ½ä¿è¯å®‰å…¨å¹¶å‘çš„è®¡æ•°å°±æ˜¯ï¼šæ¶ˆæ¯ä¼ é€’
                // çº¿ç¨‹ï¼ˆæˆ–Actorï¼‰é€šè¿‡å½¼æ­¤å‘é€æ¶ˆæ¯ï¼ˆæ•°æ®ï¼‰æ¥è¿›è¡Œé€šä¿¡
                // Goè¯­è¨€çš„åè¨€ï¼šä¸è¦ç”¨å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè¦ç”¨é€šä¿¡æ¥å…±äº«å†…å­˜
                // Rustï¼šChannelï¼ˆæ ‡å‡†åº“æä¾›ï¼‰
                // Channel
                    // åŒ…å«å‘é€ç«¯ï¼Œæ¥æ”¶ç«¯
                    // è°ƒç”¨å‘é€ç«¯çš„æ–¹æ³•ï¼Œå‘é€æ•°æ®
                    // æ¥æ”¶ç«¯ä¼šæ£€æŸ¥å’Œæ¥æ”¶åˆ°è¾¾çš„æ•°æ®
                    // å¦‚æœå‘é€ç«¯ã€æ¥æ”¶ç«¯ä¸­ä»»æ„ä¸€æ®µè¢«ä¸¢å¼ƒäº†ï¼Œé‚£ä¹ˆChannelå°±â€å…³é—­â€œäº†
                    // åˆ›å»ºChannel
                        // ä½¿ç”¨mpsc::channel()åˆ›å»ºä¸€ä¸ªé€šé“ï¼Œè¿”å›ä¸€ä¸ªå…ƒç»„ï¼ŒåŒ…å«å‘é€ç«¯å’Œæ¥æ”¶ç«¯
                        // mpsc:è¡¨ç¤º multi-producerï¼Œsingle-consumer(å¤šä¸ªç”Ÿäº§è€…ï¼Œä¸€ä¸ªæ¶ˆè´¹è€…)ï¼Œå¤šä¸ªå‘é€ç«¯ï¼Œåªæœ‰ä¸€ä¸ªæ¥æ”¶ç«¯
                            // let (tx, rx) = mpsc::channel();
                            // thread::spawn(move || {
                            //     let val = String::from("hi");
                            //     tx.send(val).unwrap();
                            // });
                            // // recv()ä¸€ç›´é˜»å¡ç›´åˆ°æ¥æ”¶åˆ°æ•°æ®
                            // let received = rx.recv().unwrap();
                            // println!("Got: {}", received);
                        // å‘é€ç«¯sendæ–¹æ³•
                            // å‚æ•°ï¼šæƒ³è¦å‘é€çš„æ•°æ®
                            // è¿”å›å€¼ï¼šResult<T, E>ï¼šå¦‚æœæœ‰é—®é¢˜ï¼ˆæ¥æ”¶ç«¯å·²ç»è¢«ä¸¢å¼ƒï¼‰ï¼Œå°±è¿”å›ä¸€ä¸ªé”™è¯¯
                        // æ¥æ”¶ç«¯çš„æ–¹æ³•ï¼š
                            // recvæ–¹æ³•ï¼š
                                // é˜»å¡å½“å‰çº¿ç¨‹ï¼ŒçŸ¥é“Channelä¸­æœ‰å€¼è¢«é€æ¥
                                // ä¸€æ—¦æœ‰å€¼æ”¶åˆ°ï¼Œå°±è¿”å›Result<T, E>
                                // å½“å‘é€ç«¯å…³é—­ï¼Œå°±ä¼šæ”¶åˆ°ä¸€ä¸ªé”™è¯¯
                            // try_recvæ–¹æ³•ï¼š
                                // ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç«‹å³è¿”å›Result<T, E>
                                // å¦‚æœChannelä¸­æ²¡æœ‰å€¼ï¼Œå°±è¿”å›ä¸€ä¸ªé”™è¯¯
                                // å¦‚æœæœ‰å€¼ï¼Œå°±è¿”å›ä¸€ä¸ªResult<T, E>
                                // é€šå¸¸ä¼šä½¿ç”¨å¾ªç¯ç”¨æ¥æ£€æŸ¥try_recvçš„ç»“æœ
                    // Channelæ‰€æœ‰æƒè½¬ç§»
                        // æ‰€æœ‰æƒåœ¨æ¶ˆæ¯ä¼ é€’ä¸­éå¸¸é‡è¦ï¼Œèƒ½å¸®ä½ ç¼–å†™å®‰å…¨å¹¶å‘çš„ä»£ç 
                            // let (tx, rx) = mpsc::channel();
                            // thread::spawn(move || {
                            //     let val = String::from("hi");
                            //     tx.send(val).unwrap();
                            //     println!("val sent {}", val);  // è¿™é‡ŒæŠ¥é”™ï¼Œvalue borrowed here after moveï¼Œè¡¨ç¤ºvalå·²ç»è½¬ç§»äº†æ‰€æœ‰æƒ
                            // });
                            // // recv()ä¸€ç›´é˜»å¡ç›´åˆ°æ¥æ”¶åˆ°æ•°æ®
                            // let received = rx.recv().unwrap();
                            // println!("Got: {}", received);
                    // å‘é€å¤šä¸ªå€¼ï¼Œæ¥å—è€…ç­‰å¾…
                        // let (tx, rx) = mpsc::channel();
                        // thread::spawn(move || {
                        //     let vals = vec![
                        //         String::from("hi"),
                        //         String::from("from"),
                        //         String::from("the"),
                        //     ];
                        //     for i in vals {
                        //         tx.send(i).unwrap();
                        //         thread::sleep(Duration::from_secs(2));
                        //     }
                        // });
                        // for received in rx {
                        //     println!("Got: {}", received);
                        // }
                    // å…‹éš†å¤šä¸ªå‘é€è€…
                        // let (tx, rx) = mpsc::channel();
                        // let tx1 = mpsc::Sender::clone(&tx);  // xxx.clone()ä¼šå¢åŠ counter+1ï¼Œæ‰€ä»¥å½“tx counter==0,rxå°±çŸ¥é“å·²ç»ç»“æŸäº†
                        // thread::spawn(move || {
                        //     let vals = vec![
                        //         String::from("1: hi"),
                        //         String::from("1: from"),
                        //         String::from("1: the"),
                        //         String::from("1: thread"),
                        //     ];

                        //     for i in vals {
                        //         tx.send(i).unwrap();
                        //         thread::sleep(Duration::from_secs(1));
                        //     }
                        // });
                        // thread::spawn(move || {
                        //     let vals = vec![
                        //         String::from("2: hi"),
                        //         String::from("2: from"),
                        //         String::from("2: the"),
                        //         String::from("2: thread"),
                        //     ];

                        //     for i in vals {
                        //         tx1.send(i).unwrap();
                        //         thread::sleep(Duration::from_secs(1));
                        //     }
                        // });
                        // for received in rx {
                        //     println!("Got: {}", received);
                        // }
            // å…±äº«çŠ¶æ€çš„å¹¶å‘
                // Goè¯­è¨€ï¼šä¸è¦ç”¨å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè¦ç”¨é€šä¿¡æ¥å…±äº«å†…å­˜
                // Rustæ”¯æŒé€šè¿‡å…±äº«çŠ¶æ€æ¥å®ç°å¹¶å‘
                // Channelç±»ä¼¼å•æ‰€æœ‰æƒï¼Œä¸€æ—¦å°†å€¼çš„æ‰€æœ‰æƒè½¬ç§»è‡³Channelï¼Œå°±æ— æ³•ä½¿ç”¨å®ƒäº†
                // å…±äº«å†…å­˜ç—…å•Šç±»ä¼¼å¤šæ‰€æœ‰æƒï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è®¿é—®åŒä¸€å—å†…å­˜
                // ä½¿ç”¨Mutexæ¥æ¯æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹æ¥è®¿é—®æ•°æ®
                // æƒ³è¦è®¿é—®æ•°æ®ï¼Œçº¿ç¨‹å¿…é¡»é¦–å…ˆè·å–äº’æ–¥é”ï¼ˆlockï¼‰ï¼Œlockæ•°æ®ç»“æ„æ—¶mutexçš„ä¸€éƒ¨åˆ†ï¼Œå®ƒèƒ½è·Ÿè¸ªè°å¯¹æ•°æ®æœ‰ç‹¬å è®¿é—®æƒ
                // mutexé€šå¸¸è¢«æè¿°ä¸ºï¼šé€šè¿‡é”å®šç³»ç»Ÿæ¥ä¿æŠ¤å®ƒæ‰€æŒæœ‰çš„æ•°æ®
                // ä½¿ç”¨mutexçš„ä¸¤æ¡è§„åˆ™
                    // åœ¨ä½¿ç”¨æ•°æ®ä¹‹å‰ï¼Œå¿…é¡»å°è¯•è·å–é”(lock)
                    // ä½¿ç”¨å®Œmutexæ‰€ä¿æŠ¤çš„æ•°æ®ï¼Œå¿…é¡»å¯¹æ•°æ®è¿›è¡Œè§£é”ï¼Œä»¥ä¾¿å…¶ä»–çº¿ç¨‹å¯ä»¥è·å–é”
                // Mutex<T>ï¼š
                    // é€šè¿‡Mutx::new(æ•°æ®)æ¥åˆ›å»ºMutex<T>
                    // Mutex<T>æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒåŒ…è£…äº†Tï¼Œå¹¶å…è®¸æˆ‘ä»¬é€šè¿‡Derefæ¥è·å–T
                    // è®¿é—®æ•°æ®å‰ï¼Œé€šè¿‡lockæ–¹æ³•æ¥è·å–é”ï¼Œä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œlockå¯èƒ½ä¼šå¤±è´¥
                    // è¿”å›çš„æ˜¯MutexGuard<T>ï¼Œå®ƒå®ç°äº†Derefå’Œ Drop
                        // let m = Mutex::new(5);
                        // {
                        //     let mut num = m.lock().unwrap();
                        //     *num = 6;
                        // }
                        // println!("m = {:?}", m);
                // å¤šçº¿ç¨‹å…±äº«Mutex,ä½¿ç”¨Arc<T>æ¥è¿›è¡ŒåŸå­å¼•ç”¨è®¡æ•°ï¼Œè·ŸRcç›¸ä¼¼ï¼Œä½†æ˜¯å®ƒå¯ä»¥ç”¨äºå¹¶å‘æƒ…æ™¯ï¼Œæ€§èƒ½å·®ä¸€ç‚¹
                    // let counter = Arc::new(Mutex::new(1));
                    // let mut handles = vec![];
                    // for _ in 1..10 {
                    //     let counter = Arc::clone(&counter);
                    //     let handle = thread::spawn(move || {
                    //         let mut num = counter.lock().unwrap();
                    //         *num += 1
                    //     });
                    //     handles.push(handle);
                    // }

                    // for h in handles {
                    //     h.join().unwrap();
                    // }

                    // println!("Result: {}", *counter.lock().unwrap());
                // Send å’Œ Sync trait
                    // Rustè¯­è¨€çš„å¹¶å‘ç‰¹æ€§è¾ƒå°‘ï¼Œç›®å‰è®²çš„å¹¶å‘éƒ½æ¥è‡ªæ ‡å‡†åº“è€Œä¸æ˜¯è¯­è¨€æœ¬èº«
                    // æ— éœ€å±€é™äºæ ‡å‡†åº“çš„å¹¶å‘ï¼Œå¯ä»¥è‡ªå·±å®ç°å¹¶å‘
                    // ä½†åœ¨Rustè¯­è¨€ä¸­æœ‰ä¸¤ä¸ªå¹¶å‘æ¦‚å¿µï¼š
                        // std::marker::Sync å’Œ std::marker::Send è¿™ä¸¤ä¸ªtrait
                    // Send
                        // å…è®¸çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ
                        // å®ç°Send trait çš„ç±»å‹å¯åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ
                        // Rustä¸­å‡ ä¹æ‰€æœ‰çš„ç±»å‹éƒ½å®ç°äº†Send
                        // ä½†Rc<T>æ²¡æœ‰å®ç°Sendï¼Œå®ƒåªç”¨äºå•çº¿ç¨‹æƒ…æ™¯
                        // ä»»ä½•å®Œå…¨ç”±Sendç±»å‹ç»„æˆçš„ç±»å‹ä¹Ÿè¢«æ ‡è®°ä¸ºSend
                        // æ’¤äº†åŸå§‹æŒ‡é’ˆä¹‹å¤–ï¼Œå‡ ä¹æ‰€æœ‰çš„åŸºç¡€ç±»å‹éƒ½å®ç°äº†Send
                    // Sync
                        // å®ç°Syncçš„ç±»å‹å¯ä»¥å®‰å…¨çš„å‘—å¤šä¸ªçº¿ç¨‹å¼•ç”¨
                        // ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœTæ˜¯Syncï¼Œé‚£ä¹ˆ&Tå°±æ˜¯Sendï¼Œå¼•ç”¨å¯ä»¥è¢«å®‰å…¨çš„é€å¾€å¦ä¸€ä¸ªçº¿ç¨‹
                        // åŸºç¡€ç±»å‹éƒ½æ˜¯Sync
                        // å®Œå…¨ç”±Syncç±»å‹ç»„æˆçš„ç±»å‹ä¹Ÿæ˜¯Sync
                        // ä½†Rc<T>ä¸æ˜¯Syncï¼ŒRefCell<T>å’ŒCell<T>å®¶æ—éƒ½ä¸å®æ˜¯Syncçš„
                        // Mutex<T>æ˜¯Syncçš„
                    // è½¬æ³¨æ„ï¼šæ‰‹åŠ¨æ¥å®ç°Sendå’ŒSyncæ˜¯ä¸å®‰å…¨çš„
        /* é¢å‘å¯¹è±¡ */
            // ç‰¹æ€§
                // å°è£…ï¼šéšè—å®ç°ç»†èŠ‚ï¼Œåªæš´éœ²æ¥å£ï¼Œè°ƒç”¨å¯¹è±¡å¤–éƒ¨çš„ä»£ç æ— æ³•ç›´æ¥è®¿é—®å¯¹è±¡å†…éƒ¨çš„å®ç°ç»†èŠ‚ï¼Œå”¯ä¸€å¯ä»¥ä¸å¯¹è±¡è¿›è¡Œäº¤äº’çš„æ–¹æ³•å°±æ˜¯é€šè¿‡å®ƒå…¬å¼€çš„API
                    // Rustï¼š pub å…³é”®å­—
                // ç»§æ‰¿ï¼šå­ç±»ç»§æ‰¿çˆ¶ç±»çš„æ–¹æ³•ï¼Œä½¿å¯¹è±¡å¯ä»¥æ²¿ç”¨å¦å¤–ä¸€ä¸ªå¯¹è±¡çš„æ•°æ®å’Œè¡Œä¸ºï¼Œä¸”æ— éœ€é‡å¤å®šä¹‰ç›¸å…³ä»£ç 
                    // Rustï¼šæ²¡æœ‰ç»§æ‰¿ï¼Œä»£ç å¤ç”¨é»˜è®¤traitæ–¹æ³•è¿›è¡Œä»£ç å…±äº«
                // å¤šæ€ï¼šçˆ¶ç±»å¯ä»¥æŒ‡å‘å­ç±»ï¼Œå­ç±»å¯ä»¥æŒ‡å‘çˆ¶ç±»
                    // Rustï¼šæ³›å‹å’Œtraitçº¦æŸ ï¼ˆé™å®šå‚æ•°åŒ–å¤šæ€ï¼‰
                // æŠ½è±¡ï¼šçˆ¶ç±»å®šä¹‰æ¥å£ï¼Œå­ç±»å®ç°æ¥å£ 
                // å°è£…ã€ç»§æ‰¿ã€å¤šæ€ã€æŠ½è±¡æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹çš„ä¸‰å¤§ç‰¹æ€§
            // ä¸ºå…±æœ‰è¡Œä¸ºå®šä¹‰ä¸€ä¸ªtrait
                // Rusté¿å…å°†structæˆ–enumç§°ä¸ºå¯¹è±¡ï¼Œå› ä¸ºå®ƒä»¬ä¸implå—æ˜¯åˆ†å¼€çš„
                // traitå¯¹è±¡æœ‰äº›ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„å¯¹è±¡ï¼Œä»–ä»¬æŸç§ç¨‹åº¦ä¸Šç»„åˆäº†æ•°æ®ä¸è¡Œä¸º
                // traitå¯¹è±¡ä¸ä¼ ç»Ÿå¯¹è±¡ä¸åŒçš„åœ°æ–¹ï¼šæ— æ³•ä¸ºtraitå¯¹è±¡æ·»åŠ æ•°æ®
                // traitå¯¹è±¡è¢«ä¸“é—¨ç”¨äºæŠ½è±¡æŸäº›å…±æœ‰è¡Œä¸ºï¼Œå®ƒæ²¡å…¶ä»–è¯­è¨€ä¸­çš„å¯¹è±¡é‚£ä¹ˆé€šç”¨
                    // let screen = Screen {
                    //     components: vec![
                    //         Box::new(SelectBox {
                    //             width: 75,
                    //             height: 10,
                    //             options: vec![
                    //                 String::from("Yes"),
                    //                 String::from("Maybe"),
                    //                 String::from("No"),
                    //             ],
                    //         }),
                    //         Box::new(Button {
                    //             width: 50,
                    //             height: 10,
                    //             label: String::from("OK"),
                    //         }),
                    //     ]
                    // };
                    // screen.run();
            // Trait å¯¹è±¡æ‰§è¡Œçš„æ˜¯åŠ¨æ€æ´¾å‘
                // å°† trait çº¦æŸä½œç”¨äºæ³›å‹æ—¶ï¼Œ Rust ç¼–è¯‘å™¨ä¼šæ‰§è¡Œå•æ€åŒ–ï¼š
                    // ç¼–è¯‘å™¨ä¼šä¸ºæˆ‘ä»¬ç”¨æ¥æ›¿æ¢æ³›å‹ç±»å‹å‚æ•°çš„æ¯ä¸€ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆå¯¹åº”å‡½æ•°å’Œæ–¹æ³•çš„éæ³›å‹å®ç°ã€‚
                // é€šè¿‡å•æ€åŒ–ç”Ÿæˆçš„ä»£ç ä¼šæ‰§è¡Œé™æ€æ´¾å‘ï¼ˆ static dispatch )ï¼Œåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ç¡®å®šè°ƒç”¨çš„å…·ä½“æ–¹æ³•
                // åŠ¨æ€æ´¾å‘ï¼ˆ dynamic dispatch ):
                    // æ— æ³•åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ç¡®å®šä½ è°ƒç”¨çš„ç©¶ç«Ÿæ˜¯å“ªä¸€ç§æ–¹æ³•
                    // ç¼–è¯‘å™¨ä¼šäº§ç”Ÿé¢å¤–çš„ä»£ç ä»¥ä¾¿åœ¨è¿è¡Œæ—¶æ‰¾å‡ºå¸Œæœ›è°ƒç”¨çš„æ–¹æ³•
                // ä½¿ç”¨ trait å¯¹è±¡ï¼Œä¼šæ‰§è¡ŒåŠ¨æ€æ´¾å‘ï¼š
                    // äº§ç”Ÿè¿è¡Œæ—¶å¼€é”€
                    // é˜»æ­¢ç¼–è¯‘å™¨å†…è”æ–¹æ³•ä»£ç ï¼Œä½¿å¾—éƒ¨åˆ†ä¼˜åŒ–æ“ä½œæ— æ³•è¿›è¡Œ
            // Trait å¯¹è±¡å¿…é¡»ä¿è¯å¯¹è±¡å®‰å…¨
                // åªèƒ½æŠŠæ»¡è¶³å¯¹è±¡å®‰å…¨ï¼ˆobject-safeï¼‰çš„traitè½¬åŒ–ä¸ºtraitå¯¹è±¡
                // Rusté‡‡ç”¨ä¸€ç³»åˆ—è§„åˆ™æ¥åˆ¤å®šæŸä¸ªå¯¹è±¡æ˜¯å¦å®‰å…¨ï¼Œåªéœ€è¦è®°ä½ä¸¤æ¡
                    // æ–¹æ³•è¿”å›ç±»å‹ä¸æ˜¯Self
                    // æ–¹æ³•ä¸­ä¸åŒ…å«ä»»ä½•æ³›å‹å‚æ•°
            // å®ç°é¢å‘å¯¹è±¡çš„è®¾è®¡æ¨¡å¼
                // çŠ¶æ€æ¨¡å¼ï¼šæ˜¯ä¸€ç§é¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼
                // ä¸€ä¸ªå€¼æ‹¥æœ‰çš„å†…éƒ¨çŠ¶æ€ç”±æ•°ä¸ªçŠ¶æ€å¯¹è±¡ç»„æˆï¼Œå½“å€¼éœ€è¦æ”¹å˜çŠ¶æ€æ—¶ï¼Œä¼šæ”¹å˜çŠ¶æ€å¯¹è±¡ï¼Œè€Œä¸æ˜¯æ”¹å˜å€¼æœ¬èº«
                // ä½¿ç”¨çŠ¶æ€æ¨¡å¼æ„å‘³ç€ï¼š
                    // ä¸šåŠ¡éœ€æ±‚å˜åŒ–æ—¶ï¼Œä¸éœ€è¦ä¿®æ”¹æŒæœ‰çŠ¶æ€çš„å€¼çš„ä»£ç ï¼Œæˆ–è€…ä½¿ç”¨è¿™ä¸ªå€¼çš„ä»£ç 
                    // åªéœ€è¦æ›´æ–°çŠ¶æ€å¯¹è±¡å†…éƒ¨çš„ä»£ç ï¼Œä»¥ä¾¿æ”¹å˜å…¶è§„åˆ™ï¼Œæˆ–è€…å¢åŠ ä¸€äº›æ–°çš„çŠ¶æ€å¯¹è±¡
                        // let mut post = Post::new();
                        // post.add_text("I ate a salad for lunch today");
                        // let post1 = post.request_review();
                        // let post2 = post1.approve();
                        // println!("{}", post2.content())
        /* æ¨¡å¼åŒ¹é… */
            // æ¨¡å¼æ˜¯ Rust ä¸­çš„ä¸€ç§ç‰¹æ®Šè¯­æ³•ï¼Œç”¨äºåŒ¹é…å¤æ‚å’Œç®€å•ç±»å‹çš„ç»“æ„
            // å°†æ¨¡å¼ä¸åŒ¹é…è¡¨è¾¾å¼å’Œå…¶ä»–æ„é€ ç»“åˆä½¿ç”¨ï¼Œå¯ä»¥æ›´å¥½åœ°æ§åˆ¶ç¨‹åºçš„æ§åˆ¶æµ.æ¨¡å¼ç”±ä»¥ä¸‹å…ƒç´ ï¼ˆçš„ä¸€äº›ç»„åˆï¼‰ç»„æˆï¼š
                // å­—é¢å€¼
                // è§£æ„çš„æ•°ç»„ã€ enum ã€ struct å’Œ tuple 
                // å˜é‡
                // é€šé…ç¬¦
                // å ä½ç¬¦
            // æƒ³è¦ä½¿ç”¨æ¨¡å¼ï¼Œéœ€è¦å°†å…¶ä¸æŸä¸ªå€¼è¿›è¡Œæ¯”è¾ƒï¼šå¦‚æœæ¨¡å¼åŒ¹é…ï¼Œå°±å¯ä»¥åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸ªå€¼çš„ç›¸åº”éƒ¨åˆ†
            // ç”¨åˆ°æ¨¡å¼çš„åœ°æ–¹
                // match çš„Armï¼ˆåˆ†æ”¯ï¼‰
                    // matchè¡¨è¾¾å¼çš„è¦æ±‚ï¼šå°½å¯èƒ½çš„åŒ…å«æ‰€æœ‰çš„å¯èƒ½æ€§
                    // _ é€šé…ç¬¦ï¼šåŒ¹é…ä»»ä½•å€¼ï¼Œä½†æ˜¯ä¸ä¼šç»‘å®šåˆ°å˜é‡ï¼Œé€šå¸¸ç”¨äºmatchçš„æœ€åä¸€ä¸ªarmï¼Œæˆ–ç”¨äºå¿½ç•¥æŸäº›å€¼
                // if let è¡¨è¾¾å¼
                    //  if let è¡¨è¾¾å¼ä¸»è¦ä½œä¸ºä¸€ç§ç®€çŸ­çš„æ–¹å¼æ¥ç­‰ä»·çš„ä»£æ›¿åªæœ‰ä¸€ä¸ªåŒ¹é…é¡¹çš„match
                    // if let å¯é€‰çš„å¯ä»¥æ‹¥æœ‰elseï¼Œelse if æˆ– else if letï¼Œä½†æ˜¯if let ä¸ä¼šæ£€æŸ¥ç©·å°½æ€§
                        // let favorite_color: Option<&str> = None;
                        // let favorite_color: Option<&str> = Some("pink");
                        // let is_tuesday = false;
                        // let age: Result<u8, _> = "35".parse();
                        // if let Some(color) = favorite_color {
                        //     println!("ä½¿ç”¨ä½ å–œæ¬¢çš„ {} ä½œä¸ºèƒŒæ™¯è‰²", color);
                        // } else if is_tuesday {
                        //     println!("ä»Šå¤©æ˜¯å‘¨äºŒï¼Œæ‰€ä»¥ä»Šå¤©æ˜¯ä¼‘æ¯æ—¥");
                        // } else if let Ok(age) = age {
                        //     if age > 30 {
                        //         println!("ä½ å¤ªè€äº†ï¼Œä¸èƒ½å·¥ä½œäº†");
                        //     } else {
                        //         println!("ä½ å¤ªå¹´è½»äº†ï¼Œç»§ç»­åŠªåŠ›å§");
                        //     }
                        // } else {
                        //     println!("ä½¿ç”¨è“è‰²ä½œä¸ºèƒŒæ™¯è‰²é¢œè‰²");
                        // }
                // while letæ¡ä»¶å¾ªç¯
                    // åªè¦æ¨¡å¼ç»§ç»­æ»¡è¶³åŒ¹é…æ¡ä»¶ï¼Œwhileå¾ªç¯å°±ä¸€ç›´è¿è¡Œ 
                        // let mut stack = Vec::new();
                        // stack.push(1);
                        // stack.push(2);
                        // stack.push(3);
                        // while let Some(x) = stack.pop() {
                        //     // popä»æœ€åé¢ä¸€ä¸ªåŒºåŸŸå¼¹å‡ºä¸€ä¸ªå…ƒç´ 
                        //     println!("{}", x);
                        // }
                // for å¾ªç¯
                    // let v = vec![1, 2, 3];
                    // for i in &v {
                    //     println!("{}", i);
                    // }
                    // for (i, v) in v.iter().enumerate() {
                    //     println!("ç¬¬{}ä¸ªå…ƒç´ æ˜¯{}", i, v);
                    // }
                // let æ¨¡å¼
                    // let a = "d";
                    // let (b,c,d) = (1,2,"str");
                    // println!("{},{},{}, {}",a,b,c,d);
                // å‡½æ•°çš„å‚æ•°ä¹Ÿæ˜¯æ¨¡å¼
            // æ¨¡å¼çš„ä¸¤ç§æ–¹å¼
                // å¯è¾¨é©³çš„ï¼Œå¯å¤±è´¥,å¯¹äºæŸäº›å¯èƒ½å¾—å€¼ï¼Œæ— æ³•è¿›è¡ŒåŒ¹é…æ¨¡å¼
                    // if let Some(x) = a_value;
                // æ— å¯è¾©é©³çš„
                    // let x = 5;
                // if let å’Œ while let æ¥æ”¶å¯è¾¨é©³å’Œæ— å¯è¾©é©³çš„æ¨¡å¼
            // æ¨¡å¼åŒ¹é…çš„è¯­æ³•ï¼ˆå…¨æ˜¯å¾ˆç®€å•çš„ä¾‹å­ï¼Œä¸åœ¨è¿™é‡Œå†™äº†ï¼‰
                // @ ç»‘å®šï¼šå¯ä»¥åˆ›å»ºä¸€ä¸ªå˜é‡ï¼Œè¯¥å˜é‡å¯ä»¥åœ¨æµ‹è¯•æŸä¸ªå€¼ä¸Šè¿›è¡ŒåŒ¹é…æ—¶ï¼ŒåŒæ—¶ä¿å­˜è¯¥å€¼
                    // let msg = Message::Hello { id: 5 };
                    // match msg {
                    //     Message::Hello {
                    //         // id è¦åœ¨3-7ä¹‹é—´çš„èŒƒå›´å†…
                    //         id: id_variable @ 3..=7,
                    //     } => {
                    //         println!("id æ˜¯ {}", id_variable);
                    //     }
                    //     Message::Hello { id: 10..=12 } => {
                    //         println!("æ‰¾åˆ°idå¦ä¸€ä¸ª");
                    //     }
                    //     Message::Hello { id } => {
                    //         println!("id æ˜¯ {}", id);
                    //     }
                    // }
        /* Rusté«˜çº§ä½¿ç”¨ */
            // ä¸å®‰å…¨çš„Rustï¼Œunsafe
            // Unsafe Rustå­˜åœ¨çš„åŸå› 
                // é™æ€åˆ†ææ˜¯ä¿å®ˆçš„ï¼Œä½¿ç”¨unsafe Rustè¡¨ç¤ºï¼Œæˆ‘çŸ¥é“è‡ªå·±åœ¨åšä»€ä¹ˆï¼Œå¹¶æ‰¿æ‹…ç›¸åº”çš„é£é™©
                // è®¡ç®—æœºç¡¬ä»¶æœ¬èº«å°±æ˜¯ä¸å®‰å…¨çš„ï¼ŒRustéœ€è¦èƒ½å¤Ÿè¿›è¡Œåº•å±‚ç³»ç»Ÿç¼–ç¨‹
            // unsafe ä½¿ç”¨æ–¹å¼
                // ä½¿ç”¨unsafeå…³é”®å­—æ¥åˆ‡æ¢åˆ°unsafe Rustï¼Œå¼€å¯ä¸€ä¸ªå—ï¼Œé‡Œé¢æ”¾ç€unsafeä»£ç 
                // unsafe Rusté‡Œé¢å¯æ‰§è¡Œçš„å››ä¸ªåŠ¨ä½œï¼š
                    // è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
                    // è°ƒç”¨unsafeå‡½æ•°æˆ–æ–¹æ³•
                    // è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡
                    // å®ç°unsafe trait
                // æ³¨æ„ï¼š
                    // unsafeå¹¶æ²¡æœ‰å…³é—­å€Ÿç”¨æ£€æŸ¥æˆ–åœç”¨å…¶ä»–å®‰å…¨æ£€æŸ¥
                    // ä»»ä½•å†…å­˜å®‰å…¨ç›¸å…³çš„é”™è¯¯å¿…é¡»ç•™åœ¨unsafeå—é‡Œ
                    // å°½å¯èƒ½éš”ç¦»unsafeä»£ç ï¼Œæœ€å¥½å°†å…¶å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡é‡Œï¼Œæä¾›å®‰å…¨çš„API
                // è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
                    // åŸå§‹æŒ‡é’ˆ
                        // å¯å˜çš„ï¼š* mut T 
                        // ä¸å¯å˜çš„ï¼š* const T ã€‚æ„å‘³ç€æŒ‡é’ˆåœ¨è§£å¼•ç”¨åä¸èƒ½ç›´æ¥å¯¹å…¶è¿›è¡Œèµ‹å€¼
                        // æ³¨æ„ï¼šè¿™é‡Œçš„ï¼Šä¸æ˜¯è§£å¼•ç”¨ç¬¦å·ï¼Œå®ƒæ˜¯ç±»å‹åçš„ä¸€éƒ¨åˆ†ã€‚
                    // ä¸å¼•ç”¨ä¸åŒï¼ŒåŸå§‹æŒ‡é’ˆï¼š
                        // å…è®¸é€šè¿‡åŒæ—¶å…·æœ‰ä¸å¯å˜å’Œå¯å˜æŒ‡é’ˆæˆ–å¤šä¸ªæŒ‡å‘åŒä¸€ä½ç½®çš„å¯å˜æŒ‡é’ˆæ¥å¿½ç•¥å€Ÿç”¨è§„åˆ™
                        // æ— æ³•ä¿è¯èƒ½æŒ‡å‘åˆç†çš„å†…å­˜
                        // å…è®¸ä¸º null 
                        // ä¸å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†
                    // æ”¾å¼ƒä¿è¯çš„å®‰å…¨ï¼Œæ¢å–æ›´å¥½çš„æ€§èƒ½ï¼ä¸å…¶å®ƒè¯­è¨€æˆ–ç¡¬ä»¶æ¥å£çš„èƒ½åŠ›
                        // let mut num = 5;
                        // // r1, r2, r éƒ½ä¸ºåŸå§‹æŒ‡é’ˆ
                        // let r1 = &num as *const i32;
                        // let r2 = &mut num as *mut i32;
                        // let address = 0x012345usize;
                        // unsafe {
                        //     println!("r1 is: {}", *r1);
                        //     println!("r2 is: {}", *r2)
                        // }
                        // let r = address as *const i32;
                        // unsafe {
                        //     println!("r is: {}", *r);  // è¿è¡Œä¼šæŠ¥é”™
                        // }
                    // ä¸ºä»€ä¹ˆè¦ä½¿ç”¨åŸå§‹æŒ‡é’ˆ
                        // 1.ä¸Cè¯­è¨€è¿›è¡Œæ¥å£
                        // 2.æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡
                    // è°ƒç”¨ unsafe å‡½æ•°æˆ–æ–¹æ³•
                        // unsafe å‡½æ•°æˆ–æ–¹æ³•ï¼šåœ¨å®šä¹‰å‰åŠ ä¸Šäº† unsafe å…³é”®å­—
                        // è°ƒç”¨å‰éœ€æ‰‹åŠ¨æ»¡è¶³ä¸€äº›æ¡ä»¶ï¼ˆä¸»è¦é çœ‹æ–‡æ¡£ï¼‰ï¼Œå› ä¸º Rust æ— æ³•å¯¹è¿™äº›æ¡ä»¶è¿›è¡ŒéªŒè¯
                        // éœ€è¦åœ¨ unsafe å—é‡Œè¿›è¡Œè°ƒç”¨
                            // unsafe {
                            //     dangerous();
                            // }

                            // let mut tl = vec![1,2,3,4,5,6,7,8,56];
                            // let r = &mut tl[..];
                            // let (a, b) = r.split_at_mut(3);
                            // println!("{:?}", a);
                            // println!("{:?}", b)
                    // ä½¿ç”¨externå‡½æ•°è°ƒç”¨å¤–éƒ¨ä»£ç 
                        // externå…³é”®å­—ï¼šç®€åŒ–åˆ›å»ºå’Œä½¿ç”¨å¤–éƒ¨å‡½æ•°æ¥å£ï¼ˆFFIï¼šForeign Function Interfaceï¼‰ï¼Œå®ƒå…è®¸ä¸€ç§ç¼–ç¨‹è¯­è¨€å®šä¹‰å‡½æ•°ï¼Œå¹¶è®©å…¶ä»–ç¼–ç¨‹è¯­è¨€èƒ½è°ƒç”¨è¿™äº›å‡½æ•°
                        // ä»»ä½•åœ¨externä¸­å£°æ˜çš„å‡½æ•°éƒ½æ˜¯ä¸å®‰å…¨çš„
                            // unsafe {
                            //     println!("abs(-3) = {}", abs(-3))
                            // }
                        // åº”ç”¨äºŒè¿›åˆ¶æ¥å£ï¼ˆ ABI , Application Binary Interface )ï¼šå®šä¹‰å‡½æ•°åœ¨æ±‡ç¼–å±‚çš„è°ƒç”¨æ–¹å¼.
                            // " C " ABI æ˜¯æœ€å¸¸è§çš„ ABI ï¼Œå®ƒéµå¾ª C è¯­è¨€çš„ ABI
                        // ä»å…¶å®ƒè¯­è¨€è°ƒç”¨ Rust å‡½æ•°
                            // å¯ä»¥ä½¿ç”¨ extern åˆ›å»ºæ¥å£ï¼Œå…¶å®ƒè¯­è¨€é€šè¿‡å®ƒä»¬å¯ä»¥è°ƒç”¨ Rust çš„å‡½æ•°ï¼åœ¨ fn å‰æ·»åŠ  extern å…³é”®å­—ï¼Œå¹¶æŒ‡å®š ABI 
                            // è¿˜éœ€æ·»åŠ #[ no _ mangle ]æ³¨è§£ï¼šé¿å… Rust åœ¨ç¼–è¯‘æ—¶æ”¹å˜å®ƒçš„åç§°
                            // è¿™ç±»çš„ä¸éœ€è¦ä½¿ç”¨unsafe
                    // è®¿é—®æˆ–ä¿®æ”¹ä¸€ä¸ªå¯å˜é™æ€å˜é‡
                        // åœ¨Rusté‡Œï¼Œå…¨å±€å˜é‡å«åšé™æ€ï¼ˆstaticï¼‰å˜é‡
                            // println!("{}", HELLO_WORLD);
                        // é™æ€å˜é‡
                            // é™æ€å˜é‡ä¸å¸¸é‡ç±»ä¼¼
                            // å‘½åï¼š SCREAMING _ SNAKE _ CASE 
                            // å¿…é¡»æ ‡æ³¨ç±»å‹
                            // é™æ€å˜é‡åªèƒ½å­˜å‚¨' static ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ï¼Œæ— éœ€æ˜¾å¼æ ‡æ³¨
                        // å¸¸é‡å’Œä¸å¯å˜é™æ€å˜é‡çš„åŒºåˆ«
                            // é™æ€å˜é‡ï¼šæœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œä½¿ç”¨å®ƒçš„å€¼æ€»ä¼šè®¿é—®åŒæ ·çš„æ•°æ®
                            // å¸¸é‡ï¼šå…è®¸ä½¿ç”¨å®ƒä»¬çš„æ—¶å€™å¯¹æ•°æ®è¿›è¡Œå¤åˆ¶
                            // é™æ€å˜é‡ï¼šå¯ä»¥æ˜¯å¯å˜çš„ï¼Œè®¿é—®å’Œä¿®æ”¹é™æ€å¯å˜å˜é‡æ˜¯ä¸å®‰å…¨ï¼ˆ unsafe ï¼‰çš„
                                // add_to_count(3);
                                // // println!("The count is: {}", COUNTER);  // æŠ¥é”™ use of mutable static
                                // unsafe {
                                //     println!("The count is: {}", COUNTER);
                                // }
            // é«˜çº§ Trait  
                // åœ¨ Trait å®šä¹‰ä¸­ä½¿ç”¨å…³è”ç±»å‹æ¥æŒ‡å®šå ä½ç±»å‹
                    // å…³è”ç±»å‹ï¼ˆ associated type ï¼‰æ˜¯ Trait ä¸­çš„ç±»å‹å ä½ç¬¦ï¼Œå®ƒå¯ä»¥ç”¨äº Trait çš„æ–¹æ³•ç­¾åä¸­ï¼š
                    // å¯ä»¥å®šä¹‰å‡ºåŒ…å«æŸäº›ç±»å‹çš„ Trait ï¼Œè€Œåœ¨å®ç°å‰æ— éœ€çŸ¥é“è¿™äº›ç±»å‹æ˜¯ä»€ä¹ˆ  
                // é»˜è®¤æ³›å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½
                    // å¯ä»¥åœ¨ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ä¸ºæ³›å‹æŒ‡å®šä¸€ä¸ªé»˜è®¤çš„å…·ä½“ç±»å‹ã€‚
                    // è¯­æ³•ï¼š< PlaceholderType = ConcreteType >
                    // è¿™ç§æŠ€æœ¯å¸¸ç”¨äºè¿ç®—ç¬¦é‡è½½ï¼ˆ operator overloading )
                    // Rust ä¸å…è®¸åˆ›å»ºè‡ªå·±çš„è¿ç®—ç¬¦åŠé‡è½½ä»»æ„çš„è¿ç®—ç¬¦
                    // ä½†å¯ä»¥é€šè¿‡å®ç° std :: ops ä¸­åˆ—å‡ºçš„é‚£äº› trait æ¥é‡è½½ä¸€éƒ¨åˆ†ç›¸åº”çš„è¿ç®—ç¬¦
                        // let pp = Point { x: 1, y: 0 } + Point { x: 2, y: 3 };
                        // println!("pp = {:?}", pp)
            // é«˜çº§ç±»å‹
                // newtype æ¨¡å¼å¯ä»¥
                    // ç”¨æ¥é™æ€çš„ä¿è¯å„ç§å€¼ä¹‹é—´ä¸ä¼šæ··æ·†å¹¶è¡¨æ˜å€¼çš„å•ä½
                    // ä¸ºç±»å‹çš„æŸäº›ç»†èŠ‚æä¾›æŠ½è±¡èƒ½åŠ›
                    // é€šè¿‡è½»é‡çº§çš„å°è£…æ¥éšè—å†…éƒ¨å®ç°ç»†èŠ‚
                // ä½¿ç”¨ç±»å‹åˆ«ååˆ›å»ºç±»å‹åŒä¹‰è¯
                    // . Rust æä¾›äº†ç±»å‹åˆ«åçš„åŠŸèƒ½ï¼š
                    // ï¹£ä¸ºç°æœ‰ç±»å‹ç”Ÿäº§å¦å¤–çš„åç§°ï¼ˆåŒä¹‰è¯ï¼‰
                    // ï¹£å¹¶ä¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ç±»å‹
                    // -ä½¿ç”¨ type å…³é”®å­—
                    // Â·ä¸»è¦ç”¨é€”ï¼šå‡å°‘ä»£ç å­—ç¬¦é‡å¤
                        // let x = 5;
                        // let y: Kilometers = 5;
                        // println!("x + y = {}", x + y);
                // Never ç±»å‹
                    // æœ‰ä¸€ä¸ªåä¸ºï¼çš„ç‰¹æ®Šç±»å‹ï¼š
                    // å®ƒæ²¡æœ‰ä»»ä½•å€¼ï¼Œè¡Œè¯ç§°ä¸ºç©ºç±»å‹ï¼ˆ empty type )
                    // æˆ‘ä»¬å€¾å‘äºå«å®ƒ never ç±»å‹ï¼Œå› ä¸ºå®ƒåœ¨ä¸è¿”å›çš„å‡½æ•°ä¸­å……å½“è¿”å›ç±»å‹ï¼ä¸è¿”å›å€¼çš„å‡½æ•°ä¹Ÿè¢«ç§°ä½œå‘æ•£å‡½æ•°ï¼ˆ diverging function )
                    // never ç±»å‹çš„å®ä¾‹æ°¸è¿œä¸å­˜åœ¨ï¼å¯ä»¥è¢«å¼ºåˆ¶çš„è½¬åŒ–æˆå…¶ä»–ä»»æ„ç±»å‹
                        // let guess = "";
                        // loop {
                        //     let guess: i32 = match guess.trim().parse() {
                        //         Ok(num) => num,
                        //         // è¿™é‡Œçš„continueå°±ä¼šè¿”å›ä¸€ä¸ªneverï¼Œæ‰€ä»¥ä¼šè¢«å¼ºåˆ¶çš„è½¬åŒ–æˆç¬¬ä¸€ä¸ªåˆ†æ”¯è¿”å›çš„å€¼ç±»å‹
                        //         Err(_) => continue,
                        //     };
                        // }
                // åŠ¨æ€å¤§å°å’Œ Sized Trait 
                    // Rust éœ€è¦åœ¨ç¼–è¯‘æ—¶ç¡®å®šä¸ºä¸€ä¸ªç‰¹å®šç±»å‹çš„å€¼åˆ†é…å¤šå°‘ç©ºé—´ã€‚
                    // åŠ¨æ€å¤§å°çš„ç±»å‹ï¼ˆ Dynamically Sized Types , DST ï¼‰çš„æ¦‚å¿µï¼š
                    // ç¼–å†™ä»£ç æ—¶ä½¿ç”¨åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šå¤§å°çš„å€¼
                    // str æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹ï¼ˆæ³¨æ„ä¸æ˜¯ï¼† str )ï¼šåªæœ‰è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šå­—ç¬¦ä¸²çš„é•¿åº¦ï¹£ä¸‹åˆ—ä»£ç æ— æ³•æ­£å¸¸å·¥ä½œï¼š
                        // let s1: str =" Hello there !";
                        // let s2: str =" How ' s it going ?";
                    // &stré‡Œé¢å­˜å‚¨çš„æ˜¯strçš„åœ°å€å’Œstrçš„é•¿åº¦
                // Sized trait 
                    // ä¸ºäº†å¤„ç†åŠ¨æ€å¤§å°çš„ç±»å‹ï¼Œ Rust æä¾›äº†ä¸€ä¸ª Sized trait æ¥ç¡®å®šä¸€ä¸ªç±»å‹çš„å¤§å°åœ¨
                    // ç¼–è¯‘æ—¶æ˜¯å¦å·²çŸ¥
                        // ç¼–è¯‘æ—¶å¯è®¡ç®—å‡ºå¤§å°çš„ç±»å‹ä¼šè‡ªåŠ¨å®ç°è¿™ä¸€ trait 
                        // Rust è¿˜ä¼šä¸ºæ¯ä¸€ä¸ªæ³›å‹å‡½æ•°éšå¼çš„æ·»åŠ  Sized çº¦æŸ
                            // fn gen<T>(t: T) {}  == fn gen<T: Sized>(t: T) {}
            // é«˜çº§å‡½æ•°å’Œé—­åŒ…
                // å‡½æ•°æŒ‡é’ˆ
                    // å¯ä»¥å°†å‡½æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°
                    // å‡½æ•°åœ¨ä¼ é€’è¿‡ç¨‹ä¸­ä¼šè¢«å¼ºåˆ¶è½¬åŒ–æˆfnç±»å‹
                    // fnç±»å‹å°±æ˜¯â€å‡½æ•°æŒ‡é’ˆï¼ˆfunction pointerï¼‰â€œ
                        // let answer = do_twice(add_one, 4);
                        // println!("The answer is: {}", answer)
                // å‡½æ•°æŒ‡é’ˆä¸é—­åŒ…çš„ä¸åŒ
                    // fn æ˜¯ä¸€ä¸ªç±»å‹ï¼Œä¸æ˜¯ä¸€ä¸ª trait 
                        // å¯ä»¥ç›´æ¥æŒ‡å®š fn ä¸ºå‚æ•°ç±»å‹ï¼Œä¸ç”¨å£°æ˜ä¸€ä¸ªä»¥ Fn trait ä¸ºçº¦æŸçš„æ³›å‹å‚æ•°
                    // å‡½æ•°æŒ‡é’ˆå®ç°äº†å…¨éƒ¨3ç§é—­åŒ… trait ( Fn , FnMut , FnOnce ):
                        // æ€»æ˜¯å¯ä»¥æŠŠå‡½æ•°æŒ‡é’ˆç”¨ä½œå‚æ•°ä¼ é€’ç»™ä¸€ä¸ªæ¥æ”¶é—­åŒ…çš„å‡½æ•°
                        // æ‰€ä»¥ï¼Œå€¾å‘äºæ­é…é—­åŒ… trait çš„æ³›å‹æ¥ç¼–å†™å‡½æ•°ï¼šå¯ä»¥åŒæ—¶æ¥æ”¶é—­åŒ…å’Œæ™®é€šå‡½æ•°
                        // æŸäº›æƒ…æ™¯ï¼Œåªæƒ³æ¥æ”¶ fn è€Œä¸æ¥æ”¶é—­åŒ…ï¼š
                            // ä¸å¤–éƒ¨ä¸æ”¯æŒé—­åŒ…çš„ä»£ç äº¤äº’ï¼š C å‡½æ•°
                                // let list_of_numbers = vec![1, 2, 3];
                                // let list_of_strings: Vec<String> = list_of_numbers
                                //     .iter()
                                //     .map(|i| i.to_string())
                                //     .collect();
                                // let list_of_numbers1 = vec![6, 7, 8];
                                // let list_of_strings1: Vec<String> = list_of_numbers1.iter().map(ToString::to_string).collect();
                                // println!("{:?}", list_of_strings1);
                                // println!("{:?}", list_of_strings);
                                // #[derive(Debug)]
                                // enum Status {
                                //     Value(i32),
                                //     Stop,
                                // }
                                // // å®ä¾‹åŒ–Statusæšä¸¾
                                // let v = Status::Value(3);
                                // println!("{:?}", v);
                                // let list_of_status: Vec<Status> = (0i32..20).map(Status::Value).collect();
                                // println!("{:?}", list_of_status)
                    // è¿”å›é—­åŒ…
                        // é—­åŒ…ä½¿ç”¨Traitè¿›è¡Œè¡¨è¾¾ï¼Œæ— æ³•åœ¨å‡½æ•°ä¸­ç›´æ¥è¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œå¯ä»¥è®²ä¸€ä¸ªå®ç°äº†è¯¥Traitçš„å…·ä½“ç±»å‹ä½œä¸ºè¿”å›å€¼Box<gyn Fn(i32) -> i32>
                            // fn return_c() -> Box<dyn Fn(i32) -> i32> {
                            //     Box::new(|x| x + 1)
                            // }
            // å® macro
                // å®åœ¨ Rust é‡ŒæŒ‡çš„æ˜¯ä¸€ç»„ç›¸å…³ç‰¹æ€§çš„é›†åˆç§°è°“ï¼š
                    // ä½¿ç”¨ macro_rules ï¼æ„å»ºçš„å£°æ˜å®ï¼ˆ declarative macro )
                    // 3ç§è¿‡ç¨‹å®
                        // è‡ªå®šä¹‰#[ derive ï¼½å®ï¼Œç”¨äº struct æˆ– enum ï¼Œå¯ä»¥ä¸ºå…¶æŒ‡å®šéš derive å±æ€§æ·»åŠ çš„ä»£ç 
                        // ç±»ä¼¼å±æ€§çš„å®ï¼Œåœ¨ä»»ä½•æ¡ç›®ä¸Šæ·»åŠ è‡ªå®šä¹‰å±æ€§
                        // ç±»ä¼¼å‡½æ•°çš„å®ï¼Œçœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ï¼Œå¯¹å…¶æŒ‡å®šä¸ºå‚æ•°çš„ token è¿›è¡Œæ“ä½œ 
                // å‡½æ•°ä¸å®çš„å·®åˆ«
                    // æœ¬è´¨ä¸Šï¼Œå®æ˜¯ç”¨æ¥ç¼–å†™å¯ä»¥ç”Ÿæˆå…¶å®ƒä»£ç çš„ä»£ç ï¼ˆå…ƒç¼–ç¨‹ï¼Œ metaprogramming )å‡½æ•°åœ¨å®šä¹‰ç­¾åæ—¶ï¼Œå¿…é¡»å£°æ˜å‚æ•°çš„ä¸ªæ•°å’Œç±»å‹ï¼Œå®å¯å¤„ç†å¯å˜çš„å‚æ•°
                    // ç¼–è¯‘å™¨ä¼šåœ¨è§£é‡Šä»£ç å‰å±•å¼€å®
                        // å®çš„å®šä¹‰æ¯”å‡½æ•°å¤æ‚å¾—å¤šï¼Œéš¾ä»¥é˜…è¯»ã€ç†è§£ã€ç»´æŠ¤
                        // åœ¨æŸä¸ªæ–‡ä»¶è°ƒç”¨å®æ—¶ï¼Œå¿…é¡»æå‰å®šä¹‰å®æˆ–å°†å®å¼•å…¥å½“å‰ä½œç”¨åŸŸï¼›
                        // å‡½æ•°å¯ä»¥åœ¨ä»»ä½•ä½ç½®å®šä¹‰å¹¶åœ¨ä»»ä½•ä½ç½®ä½¿ç”¨
                        // macro_rules! å³å°†å¼ƒç”¨
                // åŸºäºå±æ€§æ¥ç”Ÿæˆä»£ç çš„è¿‡ç¨‹å®
                    // è¿™ç§å½¢å¼æ›´åƒå‡½æ•°ï¼ˆæŸç§å½¢å¼çš„è¿‡ç¨‹ï¼‰ä¸€äº›
                        // æ¥æ”¶å¹¶æ“ä½œè¾“å…¥çš„ Rust ä»£ç 
                        // ç”Ÿæˆå¦å¤–ä¸€äº› Rust ä»£ç ä½œä¸ºç»“æœ
                    // ä¸‰ç§è¿‡ç¨‹å®ï¼š
                        // è‡ªå®šä¹‰æ´¾ç”Ÿ
                        // å±æ€§å®
                        // å‡½æ•°å®
                    // åˆ›å»ºè¿‡ç¨‹å®æ—¶ï¼š
                        // å®å®šä¹‰å¿…é¡»å•ç‹¬æ”¾åœ¨å®ƒä»¬è‡ªå·±çš„åŒ…ä¸­ï¼Œå¹¶ä½¿ç”¨ç‰¹æ®Šçš„åŒ…ç±»å‹
                // è‡ªå®šä¹‰deriveå®
                    // éœ€æ±‚ï¼šï¼ˆä½¿ç”¨å·¥ä½œç©ºé—´ï¼‰
                        // 1.åˆ›å»ºä¸€ä¸ª hello _ macro åŒ…ï¼Œå®šä¹‰ä¸€ä¸ªæ‹¥æœ‰å…³è”å‡½æ•° hello _ macro çš„ HelloMacro trait 
                        // 2.æˆ‘ä»¬æä¾›ä¸€ä¸ªèƒ½è‡ªåŠ¨å®ç° trait çš„è¿‡ç¨‹å®
                        // 3.åœ¨å®ƒä»¬çš„ç±»å‹ä¸Šæ ‡æ³¨ï¼ƒ[ derive ( HelloMacro )]ï¼Œè¿›è€Œå¾—åˆ° hello _ macro çš„é»˜è®¤å®ç°
                // ç±»ä¼¼å±æ€§çš„å®
                    // å±æ€§å®ä¸è‡ªå®šä¹‰ derive å®ç±»ä¼¼ï¹£å…è®¸åˆ›å»ºæ–°çš„å±æ€§
                        // ä½†ä¸æ˜¯ä¸º derive å±æ€§ç”Ÿæˆä»£ç 
                    // å±æ€§å®æ›´åŠ çµæ´»ï¼š
                        // derive åªèƒ½ç”¨äº struct å’Œ enum 
                        // å±æ€§å®å¯ä»¥ç”¨äºä»»æ„æ¡ç›®ï¼Œä¾‹å¦‚å‡½æ•°
                // ç±»ä¼¼å‡½æ•°çš„å®
                    // å‡½æ•°å®å®šä¹‰ç±»ä¼¼äºå‡½æ•°è°ƒç”¨çš„å®ï¼Œä½†æ¯”æ™®é€šå‡½æ•°æ›´åŠ çµæ´»
                    // å‡½æ•°å®å¯ä»¥æ¥æ”¶ TokenStream ä½œä¸ºå‚æ•°
                    // ä¸å¦å¤–ä¸¤ç§è¿‡ç¨‹å®ä¸€æ ·ï¼Œåœ¨å®šä¹‰ä¸­ä½¿ç”¨ Rust ä»£ç æ¥æ“ä½œ TokenStreamlet config = load_config();
    // // ä»é…ç½®æ–‡ä»¶åŠ è½½ `Config` å®ä¾‹
    // let config = load_config();
    // // æ„å»º MySQL è¿æ¥ URL
    // let url = format!(
    //     "mysql://{}:{}@{}:{}/{}",
    //     config.database.user,
    //     config.database.password,
    //     config.database.host,
    //     config.database.port,
    //     config.database.name
    // );

    // // åˆ›å»ºè¿æ¥æ± 
    // let pool = Pool::new(OptsBuilder::from_opts(Opts::from_url(&url).unwrap())).unwrap();

    // // è·å–è¿æ¥å¹¶æ‰§è¡Œç®€å•æŸ¥è¯¢
    // let mut conn = pool.get_conn().expect("æ— æ³•è¿æ¥åˆ°æ•°æ®åº“");

    // let result: Vec<String> = conn.query("SELECT 'Hello from MySQL!'").unwrap();
    // println!("{:?}", result);
                    
    ticket::run_ticket_sale();
}

// use proc_macro;
// // è¿‡ç¨‹å®
// #[some_attribute]
// pub fn some__name(input: TokenStream) -> TokenStream {
    
// }
// // å®šä¹‰å®
// #[macro_export]  // æ ‡æ³¨å½“å‰å®å¿…é¡»åœ¨å¼•å…¥åŒ…çš„ä½œç”¨åŸŸåæ‰å¯ä»¥ä½¿ç”¨
// macro_rules! vec {
//     ( $( $x:expr ),* ) => {
//         {
//             let mut temp_vec = Vec::new();
//             $(
//                 temp_vec.push($x);
//             )*
//             temp_vec
//         }
//     };
// }

// fn add_one(x: i32) -> i32 {
//     x + 1
// }

// fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
//     f(arg) + f(arg)
// }
// type Kilometers = i32;


// use std::ops::Add;
// struct Millimeters(i32);
// struct Meters(i32);

// impl Add<Meters> for Millimeters {
//     type Output = Millimeters;
//     fn add(self, other: Meters) -> Millimeters {
//         Millimeters (self.0 + (other.0 * 1000))
//     }
    
// }

// #[derive(Debug)]
// struct Point {
//     x: i32,
//     y: i32,
// }

// impl Add for Point {
//     type Output = Point;
//     fn add(self, other: Point) -> Point {
//         Point {
//             x: self.x + other.x,
//             y: self.y + other.y,
//         }
//     }
// }

// pub trait Iterator {
//     // Itemå°±æ˜¯å…³è”ç±»å‹
//     type Item;
//     fn next(&mut self) -> Option<Self::Item>;
// }
// static mut COUNTER: u32 = 0;

// fn add_to_count(inc: u32) {
//     unsafe {
//         COUNTER += inc;
//     }
// }

// static HELLO_WORLD:&str = "Hello, world!";
// #[no_mangle]
// pub extern "C" fn call_from_c() {
//     println!("å½“å‰å‡½æ•°ç¼–è¯‘å®Œè¿æ¥åå°±å¯ä»¥è¢«Cè¯­è¨€è®¿é—®äº†")
// }

// extern "C" {
//     fn abs(input: i32) -> i32;
// }

// use std::slice;

// fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
//     let len = slice.len();
//     assert!(mid <= len);
//     unsafe {
//         (
//             slice::from_raw_parts_mut(slice.as_mut_ptr(), mid),
//             slice::from_raw_parts_mut(slice.as_mut_ptr().add(mid), len - mid),
//         )
//     }
// }

// unsafe fn dangerous() {
//     println!("unsafeå‡½æ•°");
// }

// enum Message {
//     Hello { id: i32 },
// }
// use rut::{Draw, Screen, Button};

// struct SelectBox {
//     width: u32,
//     height: u32,
//     options: Vec<String>,
// }

// impl Draw for SelectBox {
//     fn draw(&self) {
//         println!("ç»˜åˆ¶ä¸€ä¸ªé€‰æ‹©æ¡†")
//     }
// }

// use std::sync::{Arc, Mutex};

// use std::sync::mpsc;
// #[derive(Debug)]
// struct Node {
//     value: i32,
//     parent: RefCell<Weak<Node>>,
//     children: RefCell<Vec<Rc<Node>>>,
// }

// use Li23::{Cons, Nil};
// #[derive(Debug)]
// enum Li23 {
//     Cons(i32, RefCell<Rc<Li23>>),
//     Nil,
// }

// impl Li23 {
//     fn tail(&self) -> Option<&RefCell<Rc<Li23>>> {
//         match self {
//             Cons(_, item) => Some(item),
//             Nil => None,
//         }
//     }
// }

// #[derive(Debug)]
// enum LiTwo {
//     Cons(Rc<RefCell<i32>>, Rc<LiTwo>),
//     Nil,
// }
// use LiTwo::{Cons, Nil};

// use Lii::{Cons, Nil};
// use std::rc::Rc;
// enum Lii {
//     Cons(i32, Rc<Lii>),
//     Nil,
// }

// enum Lii {
//     Cons(i32, Box<Lii>),
//     Nil,
// }

// struct CustomStruct {
//     data: String,
// }

// impl Drop for CustomStruct {
//     fn drop(&mut self) {
//         println!("{}", self.data);
//     }
// }


// use std::ops::Deref;
// struct MyBox<T>(T); //æ˜¯ä¸€ä¸ªå…ƒç»„ç±»å‹

// impl<T> MyBox<T> {
//     fn new(a: T) -> MyBox<T>{
//         MyBox(a)
//     }
// }

// impl <T> Deref for MyBox<T> {
//     type Target = T;  // å®šä¹‰äº†Deref trait çš„ å…³è”ç±»å‹
//     fn deref(&self) -> &Self::Target {
//         &self.0
//     }
// }

// fn hello(name: &str) {
//     println!("Hello, {}!", name)
// }

// åˆ›å»ºå¼‚æ­¥è¿è¡Œæ—¶
// az().await;
// use tokio::fs::File as AsyncFile;
// use tokio::io::AsyncReadExt;

// // å¼‚æ­¥å‡½æ•°ï¼Œè¯»å–æ–‡ä»¶æµå¹¶ä¼ é€’ç»™å¦ä¸€ä¸ªå‡½æ•°
// async fn az() {
//     // å¼‚æ­¥è¯»å–æ–‡ä»¶æµ
//     let mut file = AsyncFile::open("example.txt").await.unwrap();
//     let mut contents = Vec::new();
//     file.read_to_end(&mut contents).await.unwrap();
//     // å¼‚æ­¥å‡½æ•°æ‰§è¡Œå®Œæ¯•åè°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°å¹¶å°†æ–‡ä»¶æµå†…å®¹ä½œä¸ºå‚æ•°ä¼ é€’
//     // å°†å­—èŠ‚å‘é‡è½¬æ¢ä¸ºå­—ç¬¦ä¸²
//     let contents_string = String::from_utf8_lossy(&contents).to_string();
//     another_function(contents_string);
// }

// // ç¬¬äºŒä¸ªå‡½æ•°ï¼Œæ¥æ”¶æ–‡ä»¶æµå†…å®¹ä½œä¸ºå‚æ•°
// fn another_function(contents: String) {
//     // è¿™é‡Œå¯ä»¥å¯¹æ–‡ä»¶æµå†…å®¹è¿›è¡Œå¤„ç†

//     println!("Received contents: {:?}", contents);
// }

// use std::thread;
// use std::time::Duration;
// use std::iter::Iterator;

// use crate::List::{Cons, Nil};
// #[derive(Debug)]
// enum List {
//     Cons(i32, Box<List>),
//     Nil,
// }


// struct Counter {
//     count: u32,
// }

// impl Counter {
//     fn new() -> Counter {
//         Counter { count: 0 }
//     }
// }

// // åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨
// impl Iterator for Counter {
//     // å…³è”ç±»å‹
//     type Item = u32;

//     fn next(&mut self) -> Option<Self::Item> {
//         if self.count < 5 {
//             self.count += 1;
//             Some(self.count)
//         } else {
//             None
//         }
//     }
// }

// #[derive(Debug)]
// struct Shoe {
//     size: i32,
//     style: String,
// }

// fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: i32) -> Vec<Shoe> {
//     // into_iter åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¿­ä»£å™¨ä¼šéå†Vecä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ã€‚
//     // collect äº§ç”Ÿä¸€ä¸ªé›†åˆï¼Œè¿™ä¸ªé›†åˆæ˜¯Vecç±»å‹ã€‚
//     shoes.into_iter()
//         .filter(|s| s.size == shoe_size)
//         .collect() 
// }

// fn iterator_run() {
//     let v1 = vec![1, 2, 3];
//     let v1_iter = v1.iter();
//     let total: i32 = v1_iter.sum();
//     assert_eq!(total, 6)
// }
// struct Cacher<T>
// where
//     T: Fn(u32) -> u32,
// {
//     calculation: T,
//     value: Option<u32>,
// }


// impl<T> Cacher<T>
// where
//     T: Fn(u32) -> u32,
// {
//     fn new(calculation: T) -> Cacher<T> {
//         Cacher {
//             calculation,
//             value: None,
//         }
//     }

//     fn value(&mut self, arg: u32) -> u32 {
//         match self.value {
//             // å¦‚æœæœ‰å€¼ï¼Œç›´æ¥è¿”å›ï¼Œå¦‚æœæ²¡æœ‰å€¼ï¼Œæ‰§è¡Œä¸€æ¬¡è®¡ç®—ï¼Œå¹¶ä¿å­˜ç»“æœï¼Œè€Œä¸”fnè¿”å›v
//             Some(v) => v,
//             None => {
//                 let v = (self.calculation)(arg);
//                 self.value = Some(v);
//                 v
//             }
//         }
//     } 
// }  

// fn generate_workout(intensity: u32, random_number: i32) {

//     // å®šä¹‰ä¸€ä¸ªé—­åŒ…
//     let mut expensive_closure = Cacher::new(|num| {
//         println!("calculating slowly...");
//         thread::sleep(Duration::from_secs(2));
//         num
//     });

//     if intensity < 25 {
//         println!("Today, do {} pushups!", expensive_closure.value(intensity));
//         println!("Next, do {} situps!", expensive_closure.value(intensity));
//     } else {
//         if random_number == 3 {
//             println!("Take a break today! Remember to stay hydrated!");
//         } else {
//             println!("Today, run for {} minutes!", expensive_closure.value(intensity));
//             }
//         }
// }

// pub fn greeting(name: &str) -> String {
//     format!("Hello {}!", name)
// }

// pub fn greetings_contain_name() {
//     let result = greeting("Carol");
//     assert!(result.contains("Carole"), "æœªè·å–åˆ°åå­—åŒ…å«Caroleçš„æ•°æ®, :{}", result)
// }


// pub fn add_two(a: i32) -> i32 {
//     a + 2
// }

// pub fn it_add_two() {
//     // assert_eq!(4, add_two(3))
//     assert_ne!(4, add_two(2))
// }

// fn longest_with_an_answer<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str 
// where
//     T: Display,
// {
//     println!("ann{}", ann);
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

// struct ImportantExcerpt<'a> {
//     part: &'a str,
//     excerpt: &'a str,
// }

// impl <'a> ImportantExcerpt<'a> {
//     fn level(&self) -> i32 {
//         4
//     }

//     fn another_fun(&self, an: &str) -> &str {
//         // å› ä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ˜¯selfï¼Œæ‰€ä»¥å°†æ‰€æœ‰çš„å…¥å‚ä»¥åŠè¿”å›å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸéƒ½ç»‘å®šäºselfçš„ç”Ÿå‘½å‘¨æœŸ
//         println!("æ‰§è¡Œanother_fun: {}", an);
//         self.part
//     }
// }

// // å¦‚æœç›´æ¥è¿™æ ·ï¼Œä¼šæŠ¥é”™ï¼Œå› ä¸ºxï¼Œyéƒ½ä¸çŸ¥é“ç”Ÿå‘½å‘¨æœŸ
// // fn longest(x: &str, y: &str) -> &str {
// fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

// // å®šä¹‰ä¸€ä¸ªTrait
// pub trait Summary {
//     fn summarize(&self) -> String;
//     fn summarize1(&self) -> String; 
// }

// #[derive(Debug)]
// struct Point<T, U> {
//     x: T,
//     y: U,
// }

// impl <T, U> Point<T, U> {
//     fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
//         Point {
//             x: self.x,
//             y: other.y,
//         }
//     }
// }

// #[derive(Debug)]
// struct Point<T> {
//     x: T,
//     y: T,
// }

// impl <T> Point<T> {
//     // è¿™é‡Œæ˜¯é’ˆå¯¹æ³›å‹Tä¸­å®ç°Pointçš„xå’Œyæ–¹æ³•
//     pub fn x(&self) -> &T {
//         &self.x
//     }
//     pub fn y(&self) -> &T {
//         &self.y
//     }
// } 

// impl Point<i32> {
//     // è¿™é‡Œä»…ä»…æ˜¯å®ç°Pointçš„æ–¹æ³•
//     fn x1(&self) -> &i32 {
//         &self.x
//     }
    
// }

// fn largest_fn(list: &[i32]) -> i32 {
//     let mut largest = list[0];
//     for &num in list {
//         if num > largest {
//             largest = num;
//         }
//     }
//     largest
// }

// pub struct Guess {
//     value: i32,
// }

// impl Guess {
//     pub fn new(value: i32) -> Guess {
//         if value < 1 || value > 100 {
//             panic!("è¯·ä¼ å…¥1~100ä¹‹é—´çš„æ•°å­—, ä½ è¾“å…¥çš„æ˜¯ {}.", value);
//         }
//         Guess { value }
//     }

//     pub fn value(&self) -> i32 {
//         self.value
//     }
// } 


// // é“¾å¼è°ƒç”¨
// fn read_usernam_from_file() -> Result<String, io::Error> {
//     let mut s = String::new();
//     // ä»æ–‡ä»¶ä¸­è¯»å–å†…å®¹åˆ°s
//     File::open("hello.txt")?.read_to_string(&mut s)?;
//     Ok(s)
// }

// // ?è¿ç®—ç¬¦
// fn read_usernam_from_file() -> Result<String, io::Error> {
//     let mut f = File::open("hello.txt")?;
//     let mut s = String::new();
//     // ä»æ–‡ä»¶ä¸­è¯»å–å†…å®¹åˆ°s
//     f.read_to_string(&mut s)?;
//     Ok(s)
// }

// fn read_usernam_from_file() -> Result<String, io::Error> {
//     let f = File::open("hello.txt");
//     let mut f1 = match f {
//         Ok(file) => file,
//         Err(error) => return Err(error),
//     };
//     let mut s = String::new();
//     match f1.read_to_string(&mut s) {
//         Ok(_) => Ok(s),
//         Err(error) => Err(error),
//     }
    
// }

// #[derive(Debug)]
// enum SpreadsheetCell {
//     Int(i32),
//     Float(f64),
//     Text(String),
// }

// // as æŒ‡å®šåˆ«å
// use std::fmt::Result;
// use std::io::Result as IoResult;

// fn f1() -> Result{}
// fn f2() -> IoResult{}

// use std::fmt;
// use std::io;
// // å› ä¸ºResultåç§°ç›¸åŒï¼Œæ‰€ä»¥è¦å¼•å…¥çˆ¶çº§
// fn f1() -> fmt::Result{}
// fn f2() -> io::Result{}



// fn plus_one(x: Option<i32>) -> Option<i32> {
//     match x {
//         None => None,
//         Some(i) => Some(i + 1),
//     }
    
// }

// #[derive(Debug)]
// enum UsState {
//     Alabama,
//     Alaska,
    
// }

// enum Coin {
//     Penny,
//     Nickel,
//     Dime,
//     Quarter(UsState),
    
// }

// fn value_in_coin(coin: Coin) -> u8 {
//     match coin {
//         Coin::Penny => {
//             println!("Penny!");
//             1
//         },
//         Coin::Nickel => 5,
//         Coin::Dime => 10,
//         // ç»‘å®šå€¼çš„æ¨¡å¼åŒ¹é…
//         Coin::Quarter(state) => {
//             println!("State quarter from {:?} !", state);
//             25
//         },
//     }
// }

// enum Message {
//     Quit,
//     Move {x: u32, y: u32},
//     Write(String),
//     ChangeColor(i32, i32, i32),
    
// }

// impl Message {
//     fn call(&self){
//         println!("è°ƒç”¨ call æ–¹æ³•")
//     }
// }

// enum IpAddrKind {
//     // ä¸éœ€è¦é¢å¤–ä½¿ç”¨struct
//     // æ¯ä¸ªå˜ä½“å¯ä»¥æ‹¥æœ‰ä¸åŒç±»å‹ä»¥åŠå…³è”çš„æ•°æ®é‡
//     V4(u8, u8, u8, u8),
//     V6(String),
// }

// enum IpAddrKind {
//     Ipv4,
//     Ipv6,
    
// }

// fn route(_ip_kind: IpAddrKind) {}

// struct IpAddr {
//     kind: IpAddrKind,
//     address: String,
// }

// #[derive(Debug)]  // æ·»åŠ æ­¤åˆ—æ–¹ä¾¿æ‰“å°ç»“æ„ä½“
// struct User {
//     username: String,
//     email: String,
//     active: bool,
// }

// #[derive(Debug)] 
// struct Color (i32, i32, i32);
// #[derive(Debug)] 
// struct Point (i32, i32, i32);

// #[derive(Debug)] 
// struct Rectangle {
//     width: u32,
//     length:u32,  
// }
// impl Rectangle {
//     fn area(&self) -> u32 {
//         self.width * self.length
//     }

//     fn can_hold(&self, other: &Rectangle) -> bool {
//         // åˆ¤æ–­å½“å‰é•¿æ–¹å½¢æ˜¯å¦èƒ½åŒ…å«å¦ä¸€ä¸ªé•¿æ–¹å½¢
//         self.width > other.width && self.length > other.length
        
//     }

//     fn square(size: u32) -> Rectangle {
//         Rectangle {
//             width: size,
//             length: size,
//         }
//     }
    
// }
// // è¿ç”¨assertï¼å®æ¥åˆ¤æ–­
// fn larger_can_hold_smaller() {
//     let larger = Rectangle {
//         width: 8,
//         length: 7,
//     };
//     let smaller = Rectangle {
//         width: 5,
//         length: 1,
//     };
//     // assert! å®ä¸ä¼šè¿”å›æ–­è¨€çš„ç»“æœï¼Œè€Œæ˜¯åœ¨æ–­è¨€å¤±è´¥æ—¶è§¦å‘ panic
//     assert!(larger.can_hold(&smaller));
// }

// fn area(rect: &Rectangle) -> u32{
//     // è®¡ç®—é•¿æ–¹å½¢çš„é¢ç§¯ï¼Œé•¿ * å®½
//     rect.width * rect.length
// }

// fn area(dim:(u32,u32)) -> u32{
//     // è®¡ç®—é•¿æ–¹å½¢çš„é¢ç§¯ï¼Œé•¿ * å®½
//     dim.0 * dim.1
// }

// fn area(width:u32, length:u32) -> u32{
//     // è®¡ç®—é•¿æ–¹å½¢çš„é¢ç§¯ï¼Œé•¿ * å®½
//     width * length
// }

// fn first_world(s: &str) -> &str {
//     let bytes = s.as_bytes();
//     for (i, &item) in bytes.iter().enumerate() {
//         if item == b' ' {
//             return &s[..i];
//         }
//     }
//     &s[..]
// }

// fn first_world(s: &String) -> usize {
//     let bytes = s.as_bytes();
//     for (i, &item) in bytes.iter().enumerate() {
//         if item == b' ' {
//             return i;
//         }
//     }
//     s.len()
// }

// fn danling_info() ->&String {
//     let s = String::from("hello");
//     // å½“å‡½æ•°ç»“æŸæ—¶ï¼Œså°±ä¸åœ¨å½“å‰çš„ä½œç”¨åŸŸï¼Œå°±ä¼šè¢«é”€æ¯ï¼Œä½†æ˜¯å¼•ç”¨è¢«è¿”å›ï¼Œé‚£ä¹ˆè¿™ä¸ªå¼•ç”¨çš„åœ°å€å·²ç»è¢«åˆ†é…ç»™åˆ«çš„åœ°æ–¹ä½¿ç”¨äº†ï¼Œæ‰€ä»¥æŠ¥é”™
//     &s
// }

// fn calculate_length(s: &mut String) -> usize {
//     // å¼•ç”¨,å€Ÿç”¨çš„å¦‚æœæ˜¯ä¸å¯å˜å˜é‡ï¼Œå€¼åˆ™ä¸èƒ½è¢«ä¿®æ”¹
//     s.push_str("ï¼Œæ·»åŠ çš„æ•°æ®");
//     s.len()
// }

// fn calculate_length(s: String) -> (String, usize){
//     let length = s.len();
//     (s, length)
// }

// fn gives_own() -> String {
//     let some_str = String::from("å‡½æ•°å†…éƒ¨");
//     some_str
// }

// fn takes_and_give_back(str_info: String) -> String {
//     str_info
// }

// fn take_own(some_str: String) {
//     println!("{}", some_str);
// }

// fn make_copy(some_num: i32) {
//     println!("{}", some_num);
// }

// fn another_fun(x: i32, y: i32) {  // å‡½æ•°å‚æ•°å¿…é¡»æŒ‡å®šç±»å‹
//     println!("æ‰§è¡Œå¦ä¸€ä¸ªå‡½æ•°: {} and {}", x, y)
    
// }

// fn five(x: i32) -> i32 {
//     x + 5
// }

